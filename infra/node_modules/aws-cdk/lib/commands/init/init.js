"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitTemplate = void 0;
exports.cliInit = cliInit;
exports.expandPlaceholders = expandPlaceholders;
exports.availableInitTemplates = availableInitTemplates;
exports.availableInitLanguages = availableInitLanguages;
exports.printAvailableTemplates = printAvailableTemplates;
exports.currentlyRecommendedAwsCdkLibFlags = currentlyRecommendedAwsCdkLibFlags;
const childProcess = require("child_process");
const path = require("path");
const toolkit_lib_1 = require("@aws-cdk/toolkit-lib");
const chalk = require("chalk");
const fs = require("fs-extra");
const init_hooks_1 = require("./init-hooks");
const root_dir_1 = require("../../cli/root-dir");
const version_1 = require("../../cli/version");
const util_1 = require("../../util");
const language_1 = require("../language");
const package_manager_1 = require("./package-manager");
/* eslint-disable @typescript-eslint/no-var-requires */ // Packages don't have @types module
// eslint-disable-next-line @typescript-eslint/no-require-imports
const camelCase = require('camelcase');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const decamelize = require('decamelize');
const SUPPORTED_LANGUAGE_NAMES = language_1.SUPPORTED_LANGUAGES.map((l) => l.name);
/**
 * Initialize a CDK package in the current directory
 */
async function cliInit(options) {
    await ensureValidCliInitOptions(options, options.ioHelper);
    const ioHelper = options.ioHelper;
    const canUseNetwork = options.canUseNetwork ?? true;
    const generateOnly = options.generateOnly ?? false;
    const workDir = options.workDir ?? process.cwd();
    // Show available templates only if no fromPath, type, or language provided
    if (!options.fromPath && !options.type && !options.language) {
        await printAvailableTemplates(ioHelper);
        return;
    }
    // Step 1: Load template
    let template;
    if (options.fromPath) {
        template = await loadLocalTemplate(options.fromPath, options.templatePath);
    }
    else {
        template = await loadBuiltinTemplate(ioHelper, options.type, options.language);
    }
    // Step 2: Resolve language
    const language = await resolveLanguage(ioHelper, template, options.language, options.type);
    // Step 3: Initialize project following standard process
    await initializeProject(ioHelper, template, language, canUseNetwork, generateOnly, workDir, options.projectName, options.stackName, options.migrate, options.libVersion, options.packageManager);
}
/**
 * Validate CLI init options and handle invalid or incompatible option combinations
 */
async function ensureValidCliInitOptions(options, ioHelper) {
    if (options.packageManager && !['javascript', 'typescript'].includes(options.language ?? '')) {
        await ioHelper.defaults.warn(`--package-manager option is only applicable for JavaScript and TypeScript projects. Ignoring the provided value: ${options.packageManager}`);
    }
}
/**
 * Load a local custom template from file system path
 * @param fromPath - Path to the local template directory or multi-template repository
 * @param templatePath - Optional path to a specific template within a multi-template repository
 * @returns Promise resolving to the loaded InitTemplate
 */
async function loadLocalTemplate(fromPath, templatePath) {
    try {
        let actualTemplatePath = fromPath;
        // If templatePath is provided, it's a multi-template repository
        if (templatePath) {
            actualTemplatePath = path.join(fromPath, templatePath);
            if (!await fs.pathExists(actualTemplatePath)) {
                throw new toolkit_lib_1.ToolkitError(`Template path does not exist: ${actualTemplatePath}`);
            }
        }
        const template = await InitTemplate.fromPath(actualTemplatePath);
        if (template.languages.length === 0) {
            // Check if this might be a multi-template repository
            if (!templatePath) {
                const availableTemplates = await findPotentialTemplates(fromPath);
                if (availableTemplates.length > 0) {
                    throw new toolkit_lib_1.ToolkitError('Use --template-path to specify which template to use.');
                }
            }
            throw new toolkit_lib_1.ToolkitError('Custom template must contain at least one language directory');
        }
        return template;
    }
    catch (error) {
        const displayPath = templatePath ? `${fromPath}/${templatePath}` : fromPath;
        throw new toolkit_lib_1.ToolkitError(`Failed to load template from path: ${displayPath}. ${error.message}`);
    }
}
/**
 * Load a built-in template by name
 */
async function loadBuiltinTemplate(ioHelper, type, language) {
    const templateType = type || 'default'; // "default" is the default type (and maps to "app")
    const template = (await availableInitTemplates()).find((t) => t.hasName(templateType));
    if (!template) {
        await printAvailableTemplates(ioHelper, language);
        throw new toolkit_lib_1.ToolkitError(`Unknown init template: ${templateType}`);
    }
    return template;
}
/**
 * Resolve the programming language for the template
 * @param ioHelper - IO helper for user interaction
 * @param template - The template to resolve language for
 * @param requestedLanguage - User-requested language (optional)
 * @param type - The template type name for messages
 * @default undefined
 * @returns Promise resolving to the selected language
 */
async function resolveLanguage(ioHelper, template, requestedLanguage, type) {
    return (async () => {
        if (requestedLanguage) {
            return requestedLanguage;
        }
        if (template.languages.length === 1) {
            const templateLanguage = template.languages[0];
            // Only show auto-detection message for built-in templates
            if (template.templateType !== TemplateType.CUSTOM) {
                await ioHelper.defaults.warn(`No --language was provided, but '${type || template.name}' supports only '${templateLanguage}', so defaulting to --language=${templateLanguage}`);
            }
            return templateLanguage;
        }
        await ioHelper.defaults.info(`Available languages for ${chalk.green(type || template.name)}: ${template.languages.map((l) => chalk.blue(l)).join(', ')}`);
        throw new toolkit_lib_1.ToolkitError('No language was selected');
    })();
}
/**
 * Find potential template directories in a multi-template repository
 * @param repositoryPath - Path to the repository root
 * @returns Promise resolving to array of potential template directory names
 */
async function findPotentialTemplates(repositoryPath) {
    const entries = await fs.readdir(repositoryPath, { withFileTypes: true });
    const templateValidationPromises = entries
        .filter(entry => entry.isDirectory() && !entry.name.startsWith('.'))
        .map(async (entry) => {
        try {
            const templatePath = path.join(repositoryPath, entry.name);
            const { languages } = await getLanguageDirectories(templatePath);
            return languages.length > 0 ? entry.name : null;
        }
        catch (error) {
            // If we can't read a specific template directory, skip it but don't fail the entire operation
            return null;
        }
    });
    /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Limited to directory entries
    const validationResults = await Promise.all(templateValidationPromises);
    return validationResults.filter((templateName) => templateName !== null);
}
/**
 * Get valid CDK language directories from a template path
 * @param templatePath - Path to the template directory
 * @returns Promise resolving to array of supported language names
 */
/**
 * Get valid CDK language directories from a template path
 * @param templatePath - Path to the template directory
 * @returns Promise resolving to array of supported language names and directory entries
 * @throws ToolkitError if directory cannot be read or validated
 */
async function getLanguageDirectories(templatePath) {
    try {
        const entries = await fs.readdir(templatePath, { withFileTypes: true });
        const languageValidationPromises = entries
            .filter(directoryEntry => directoryEntry.isDirectory() && SUPPORTED_LANGUAGE_NAMES.includes(directoryEntry.name))
            .map(async (directoryEntry) => {
            const languageDirectoryPath = path.join(templatePath, directoryEntry.name);
            try {
                const hasValidLanguageFiles = await hasLanguageFiles(languageDirectoryPath, (0, language_1.getLanguageExtensions)(directoryEntry.name));
                return hasValidLanguageFiles ? directoryEntry.name : null;
            }
            catch (error) {
                throw new toolkit_lib_1.ToolkitError(`Cannot read language directory '${directoryEntry.name}': ${error.message}`);
            }
        });
        /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Limited to supported CDK languages (7 max)
        const validationResults = await Promise.all(languageValidationPromises);
        return {
            languages: validationResults.filter((languageName) => languageName !== null),
            entries,
        };
    }
    catch (error) {
        throw new toolkit_lib_1.ToolkitError(`Cannot read template directory '${templatePath}': ${error.message}`);
    }
}
/**
 * Iteratively check if a directory contains files with the specified extensions
 * @param directoryPath - Path to search for language files
 * @param extensions - Array of file extensions to look for
 * @returns Promise resolving to true if language files are found
 */
async function hasLanguageFiles(directoryPath, extensions) {
    const dirsToCheck = [directoryPath];
    while (dirsToCheck.length > 0) {
        const currentDir = dirsToCheck.pop();
        try {
            const entries = await fs.readdir(currentDir, { withFileTypes: true });
            for (const entry of entries) {
                if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
                    return true;
                }
                else if (entry.isDirectory()) {
                    dirsToCheck.push(path.join(currentDir, entry.name));
                }
            }
        }
        catch (error) {
            throw error;
        }
    }
    return false;
}
/**
 * Returns the name of the Python executable for this OS
 * @returns The Python executable name for the current platform
 */
function pythonExecutable() {
    let python = 'python3';
    if (process.platform === 'win32') {
        python = 'python';
    }
    return python;
}
const INFO_DOT_JSON = 'info.json';
var TemplateType;
(function (TemplateType) {
    TemplateType["BUILT_IN"] = "builtin";
    TemplateType["CUSTOM"] = "custom";
})(TemplateType || (TemplateType = {}));
class InitTemplate {
    static async fromName(templatesDir, name) {
        const basePath = path.join(templatesDir, name);
        const languages = await listDirectory(basePath);
        const initInfo = await fs.readJson(path.join(basePath, INFO_DOT_JSON));
        return new InitTemplate(basePath, name, languages, initInfo, TemplateType.BUILT_IN);
    }
    static async fromPath(templatePath) {
        const basePath = path.resolve(templatePath);
        if (!await fs.pathExists(basePath)) {
            throw new toolkit_lib_1.ToolkitError(`Template path does not exist: ${basePath}`);
        }
        let templateSourcePath = basePath;
        let { languages, entries } = await getLanguageDirectories(basePath);
        if (languages.length === 0) {
            const languageDirs = entries.filter(entry => entry.isDirectory() &&
                SUPPORTED_LANGUAGE_NAMES.includes(entry.name));
            if (languageDirs.length === 1) {
                // Validate that the language directory contains appropriate files
                const langDir = languageDirs[0].name;
                templateSourcePath = path.join(basePath, langDir);
                const hasValidFiles = await hasLanguageFiles(templateSourcePath, (0, language_1.getLanguageExtensions)(langDir));
                if (!hasValidFiles) {
                    // If we found a language directory but it doesn't contain valid files, we should inform the user
                    throw new toolkit_lib_1.ToolkitError(`Found '${langDir}' directory but it doesn't contain the expected language files. Ensure the template contains ${langDir} source files.`);
                }
            }
        }
        const name = path.basename(basePath);
        return new InitTemplate(templateSourcePath, name, languages, null, TemplateType.CUSTOM);
    }
    constructor(basePath, name, languages, initInfo, templateType) {
        this.basePath = basePath;
        this.name = name;
        this.languages = languages;
        this.aliases = new Set();
        this.templateType = templateType;
        // Only built-in templates have descriptions and aliases from info.json
        if (templateType === TemplateType.BUILT_IN && initInfo) {
            this.description = initInfo.description;
            for (const alias of initInfo.aliases || []) {
                this.aliases.add(alias);
            }
        }
    }
    /**
     * @param name - the name that is being checked
     * @returns ``true`` if ``name`` is the name of this template or an alias of it.
     */
    hasName(name) {
        return name === this.name || this.aliases.has(name);
    }
    /**
     * Creates a new instance of this ``InitTemplate`` for a given language to a specified folder.
     *
     * @param language - the language to instantiate this template with
     * @param targetDirectory - the directory where the template is to be instantiated into
     * @param stackName - the name of the stack to create
     * @default undefined
     * @param libVersion - the version of the CDK library to use
     * @default undefined
     */
    async install(ioHelper, language, targetDirectory, projectName, stackName, libVersion, packageManager) {
        if (this.languages.indexOf(language) === -1) {
            await ioHelper.defaults.error(`The ${chalk.blue(language)} language is not supported for ${chalk.green(this.name)} ` +
                `(it supports: ${this.languages.map((l) => chalk.blue(l)).join(', ')})`);
            throw new toolkit_lib_1.ToolkitError(`Unsupported language: ${language}`);
        }
        const projectInfo = {
            name: projectName ? decamelize(projectName) : decamelize(path.basename(path.resolve(targetDirectory))),
            stackName,
            versions: await loadInitVersions(),
        };
        if (libVersion) {
            projectInfo.versions['aws-cdk-lib'] = libVersion;
        }
        let sourceDirectory = path.join(this.basePath, language);
        // For auto-detected single language templates, use basePath directly
        if (this.templateType === TemplateType.CUSTOM && this.languages.length === 1 &&
            path.basename(this.basePath) === language) {
            sourceDirectory = this.basePath;
        }
        if (this.templateType === TemplateType.CUSTOM) {
            // For custom templates, copy files without processing placeholders
            await this.installFilesWithoutProcessing(sourceDirectory, targetDirectory);
        }
        else {
            // For built-in templates, process placeholders as usual
            await this.installFiles(sourceDirectory, targetDirectory, language, projectInfo, packageManager);
            await this.applyFutureFlags(targetDirectory);
            await (0, init_hooks_1.invokeBuiltinHooks)(ioHelper, { targetDirectory, language, templateName: this.name }, {
                substitutePlaceholdersIn: async (...fileNames) => {
                    const fileProcessingPromises = fileNames.map(async (fileName) => {
                        const fullPath = path.join(targetDirectory, fileName);
                        const template = await fs.readFile(fullPath, { encoding: 'utf-8' });
                        await fs.writeFile(fullPath, expandPlaceholders(template, language, projectInfo, packageManager));
                    });
                    /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Processing a small, known set of template files
                    await Promise.all(fileProcessingPromises);
                },
                placeholder: (ph) => expandPlaceholders(`%${ph}%`, language, projectInfo, packageManager),
            });
        }
    }
    async installFiles(sourceDirectory, targetDirectory, language, project, packageManager) {
        for (const file of await fs.readdir(sourceDirectory)) {
            const fromFile = path.join(sourceDirectory, file);
            const toFile = path.join(targetDirectory, expandPlaceholders(file, language, project, packageManager));
            if ((await fs.stat(fromFile)).isDirectory()) {
                await fs.mkdir(toFile);
                await this.installFiles(fromFile, toFile, language, project, packageManager);
                continue;
            }
            else if (file.match(/^.*\.template\.[^.]+$/)) {
                await this.installProcessed(fromFile, toFile.replace(/\.template(\.[^.]+)$/, '$1'), language, project, packageManager);
                continue;
            }
            else if (file.match(/^.*\.hook\.(d.)?[^.]+$/)) {
                // Ignore
                continue;
            }
            else {
                await fs.copy(fromFile, toFile);
            }
        }
    }
    async installProcessed(templatePath, toFile, language, project, packageManager) {
        const template = await fs.readFile(templatePath, { encoding: 'utf-8' });
        await fs.writeFile(toFile, expandPlaceholders(template, language, project, packageManager));
    }
    /**
     * Copy template files without processing placeholders (for custom templates)
     */
    async installFilesWithoutProcessing(sourceDirectory, targetDirectory) {
        await fs.copy(sourceDirectory, targetDirectory, {
            filter: (src) => {
                const filename = path.basename(src);
                return !filename.match(/^.*\.hook\.(d.)?[^.]+$/);
            },
        });
    }
    /**
     * Adds context variables to `cdk.json` in the generated project directory to
     * enable future behavior for new projects.
     */
    async applyFutureFlags(projectDir) {
        const cdkJson = path.join(projectDir, 'cdk.json');
        if (!(await fs.pathExists(cdkJson))) {
            return;
        }
        const config = await fs.readJson(cdkJson);
        config.context = {
            ...config.context,
            ...await currentlyRecommendedAwsCdkLibFlags(),
        };
        await fs.writeJson(cdkJson, config, { spaces: 2 });
    }
    async addMigrateContext(projectDir) {
        const cdkJson = path.join(projectDir, 'cdk.json');
        if (!(await fs.pathExists(cdkJson))) {
            return;
        }
        const config = await fs.readJson(cdkJson);
        config.context = {
            ...config.context,
            'cdk-migrate': true,
        };
        await fs.writeJson(cdkJson, config, { spaces: 2 });
    }
}
exports.InitTemplate = InitTemplate;
function expandPlaceholders(template, language, project, packageManager) {
    const cdkCliVersion = project.versions['aws-cdk'];
    let cdkVersion = project.versions['aws-cdk-lib'];
    let constructsVersion = project.versions.constructs;
    switch (language) {
        case 'java':
            cdkVersion = (0, util_1.rangeFromSemver)(cdkVersion, 'bracket');
            constructsVersion = (0, util_1.rangeFromSemver)(constructsVersion, 'bracket');
            break;
        case 'csharp':
        case 'fsharp':
            cdkVersion = (0, util_1.rangeFromSemver)(cdkVersion, 'bracket'); // ^2.123.0 => [2.123.0,3.0.0)
            constructsVersion = (0, util_1.rangeFromSemver)(constructsVersion, 'major.*'); // ^10.0.0 => 10.*/
            break;
        case 'python':
            cdkVersion = (0, util_1.rangeFromSemver)(cdkVersion, 'pep');
            constructsVersion = (0, util_1.rangeFromSemver)(constructsVersion, 'pep');
            break;
        case 'go':
            cdkVersion = (0, util_1.stripCaret)(cdkVersion);
            constructsVersion = (0, util_1.stripCaret)(constructsVersion);
            break;
    }
    return template
        .replace(/%name%/g, project.name)
        .replace(/%stackname%/, project.stackName ?? '%name.PascalCased%Stack')
        .replace(/%PascalNameSpace%/, project.stackName ? camelCase(project.stackName + 'Stack', { pascalCase: true }) : '%name.PascalCased%')
        .replace(/%PascalStackProps%/, project.stackName ? camelCase(project.stackName, { pascalCase: true }) + 'StackProps' : 'StackProps')
        .replace(/%name\.camelCased%/g, camelCase(project.name))
        .replace(/%name\.PascalCased%/g, camelCase(project.name, { pascalCase: true }))
        .replace(/%cdk-version%/g, cdkVersion)
        .replace(/%cdk-cli-version%/g, cdkCliVersion)
        .replace(/%constructs-version%/g, constructsVersion)
        .replace(/%cdk-home%/g, (0, util_1.cdkHomeDir)())
        .replace(/%name\.PythonModule%/g, project.name.replace(/-/g, '_'))
        .replace(/%python-executable%/g, pythonExecutable())
        .replace(/%name\.StackName%/g, project.name.replace(/[^A-Za-z0-9-]/g, '-'))
        .replace(/%pm-cmd%/g, (0, package_manager_1.getPmCmdPrefix)(packageManager ?? 'npm'));
}
async function availableInitTemplates() {
    try {
        const templatesDir = path.join((0, root_dir_1.cliRootDir)(), 'lib', 'init-templates');
        const templateNames = await listDirectory(templatesDir);
        const templatePromises = templateNames.map(templateName => InitTemplate.fromName(templatesDir, templateName));
        /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Built-in templates are limited in number
        return await Promise.all(templatePromises);
    }
    catch (error) {
        // Return empty array if templates directory doesn't exist or can't be read
        // This allows the CLI to gracefully handle missing built-in templates
        if (error.code === 'ENOENT' || error.code === 'EACCES') {
            return [];
        }
        throw error;
    }
}
async function availableInitLanguages() {
    const templates = await availableInitTemplates();
    const result = new Set();
    for (const template of templates) {
        for (const language of template.languages) {
            const alias = (0, language_1.getLanguageAlias)(language);
            result.add(language);
            alias && result.add(alias);
        }
    }
    return [...result];
}
/**
 * @param dirPath - is the directory to be listed.
 * @returns the list of file or directory names contained in ``dirPath``, excluding any dot-file, and sorted.
 */
async function listDirectory(dirPath) {
    return ((await fs.readdir(dirPath))
        .filter((p) => !p.startsWith('.'))
        .filter((p) => !(p === 'LICENSE'))
        // if, for some reason, the temp folder for the hook doesn't get deleted we don't want to display it in this list
        .filter((p) => !(p === INFO_DOT_JSON))
        .sort());
}
/**
 * Print available templates to the user
 * @param ioHelper - IO helper for user interaction
 * @param language - Programming language filter
 * @default undefined
 */
async function printAvailableTemplates(ioHelper, language) {
    await ioHelper.defaults.info('Available templates:');
    for (const template of await availableInitTemplates()) {
        if (language && template.languages.indexOf(language) === -1) {
            continue;
        }
        await ioHelper.defaults.info(`* ${chalk.green(template.name)}: ${template.description}`);
        const languageArg = language
            ? chalk.bold(language)
            : template.languages.length > 1
                ? `[${template.languages.map((t) => chalk.bold(t)).join('|')}]`
                : chalk.bold(template.languages[0]);
        await ioHelper.defaults.info(`   └─ ${chalk.blue(`cdk init ${chalk.bold(template.name)} --language=${languageArg}`)}`);
    }
}
async function initializeProject(ioHelper, template, language, canUseNetwork, generateOnly, workDir, projectName, stackName, migrate, cdkVersion, packageManager) {
    // Step 1: Ensure target directory is empty
    await assertIsEmptyDirectory(workDir);
    // Step 2: Copy template files
    await ioHelper.defaults.info(`Applying project template ${chalk.green(template.name)} for ${chalk.blue(language)}`);
    await template.install(ioHelper, language, workDir, projectName, stackName, cdkVersion, packageManager);
    if (migrate) {
        await template.addMigrateContext(workDir);
    }
    if (await fs.pathExists(`${workDir}/README.md`)) {
        const readme = await fs.readFile(`${workDir}/README.md`, { encoding: 'utf-8' });
        await ioHelper.defaults.info(chalk.green(readme));
    }
    if (!generateOnly) {
        // Step 3: Initialize Git repository and create initial commit
        await initializeGitRepository(ioHelper, workDir);
        // Step 4: Post-install steps
        await postInstall(ioHelper, language, canUseNetwork, workDir, packageManager);
    }
    await ioHelper.defaults.info('✅ All done!');
}
/**
 * Validate that a directory exists and is empty (ignoring hidden files)
 * @param workDir - Directory path to validate
 * @throws ToolkitError if directory doesn't exist or is not empty
 */
async function assertIsEmptyDirectory(workDir) {
    try {
        const stats = await fs.stat(workDir);
        if (!stats.isDirectory()) {
            throw new toolkit_lib_1.ToolkitError(`Path exists but is not a directory: ${workDir}`);
        }
        const files = await fs.readdir(workDir);
        const visibleFiles = files.filter(f => !f.startsWith('.'));
        if (visibleFiles.length > 0) {
            throw new toolkit_lib_1.ToolkitError('`cdk init` cannot be run in a non-empty directory!\n' +
                `Found ${visibleFiles.length} visible files in ${workDir}:\n` +
                visibleFiles.map(f => `  - ${f}`).join('\n'));
        }
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            throw new toolkit_lib_1.ToolkitError(`Directory does not exist: ${workDir}\n` +
                'Please create the directory first using: mkdir -p ' + workDir);
        }
        throw new toolkit_lib_1.ToolkitError(`Failed to validate directory ${workDir}: ${e.message}`);
    }
}
async function initializeGitRepository(ioHelper, workDir) {
    if (await isInGitRepository(workDir)) {
        return;
    }
    await ioHelper.defaults.info('Initializing a new git repository...');
    try {
        await execute(ioHelper, 'git', ['init'], { cwd: workDir });
        await execute(ioHelper, 'git', ['add', '.'], { cwd: workDir });
        await execute(ioHelper, 'git', ['commit', '--message="Initial commit"', '--no-gpg-sign'], { cwd: workDir });
    }
    catch {
        await ioHelper.defaults.warn('Unable to initialize git repository for your project.');
    }
}
async function postInstall(ioHelper, language, canUseNetwork, workDir, packageManager) {
    switch (language) {
        case 'javascript':
            return postInstallJavascript(ioHelper, canUseNetwork, workDir, packageManager);
        case 'typescript':
            return postInstallTypescript(ioHelper, canUseNetwork, workDir, packageManager);
        case 'java':
            return postInstallJava(ioHelper, canUseNetwork, workDir);
        case 'python':
            return postInstallPython(ioHelper, workDir);
        case 'go':
            return postInstallGo(ioHelper, canUseNetwork, workDir);
        case 'csharp':
            return postInstallCSharp(ioHelper, canUseNetwork, workDir);
        case 'fsharp':
            return postInstallFSharp(ioHelper, canUseNetwork, workDir);
    }
}
async function postInstallJavascript(ioHelper, canUseNetwork, cwd, packageManager) {
    return postInstallTypescript(ioHelper, canUseNetwork, cwd, packageManager);
}
async function postInstallTypescript(ioHelper, canUseNetwork, cwd, packageManager) {
    const command = packageManager ?? 'npm';
    if (!canUseNetwork) {
        await ioHelper.defaults.warn(`Please run '${command} install'!`);
        return;
    }
    await ioHelper.defaults.info(`Executing ${chalk.green(`${command} install`)}...`);
    try {
        await execute(ioHelper, command, ['install'], { cwd });
    }
    catch (e) {
        await ioHelper.defaults.warn(`${command} install failed: ` + (0, util_1.formatErrorMessage)(e));
    }
}
async function postInstallJava(ioHelper, canUseNetwork, cwd) {
    // Check if this is a Gradle or Maven project
    const hasGradleBuild = await fs.pathExists(path.join(cwd, 'build.gradle'));
    const hasMavenPom = await fs.pathExists(path.join(cwd, 'pom.xml'));
    if (hasGradleBuild) {
        // Gradle project
        const gradleWarning = "Please run './gradlew build'!";
        if (!canUseNetwork) {
            await ioHelper.defaults.warn(gradleWarning);
            return;
        }
        await ioHelper.defaults.info("Executing './gradlew build'");
        try {
            await execute(ioHelper, './gradlew', ['build'], { cwd });
        }
        catch {
            await ioHelper.defaults.warn('Unable to build Gradle project');
            await ioHelper.defaults.warn(gradleWarning);
        }
    }
    else if (hasMavenPom) {
        // Maven project
        const mvnPackageWarning = "Please run 'mvn package'!";
        if (!canUseNetwork) {
            await ioHelper.defaults.warn(mvnPackageWarning);
            return;
        }
        await ioHelper.defaults.info("Executing 'mvn package'");
        try {
            await execute(ioHelper, 'mvn', ['package'], { cwd });
        }
        catch {
            await ioHelper.defaults.warn('Unable to package compiled code as JAR');
            await ioHelper.defaults.warn(mvnPackageWarning);
        }
    }
    else {
        // No recognized build file
        await ioHelper.defaults.warn('No build.gradle or pom.xml found. Please set up your build system manually.');
    }
}
async function postInstallPython(ioHelper, cwd) {
    const python = pythonExecutable();
    // Check if requirements.txt exists
    const hasRequirements = await fs.pathExists(path.join(cwd, 'requirements.txt'));
    if (hasRequirements) {
        await ioHelper.defaults.info(`Executing ${chalk.green('Creating virtualenv...')}`);
        try {
            await execute(ioHelper, python, ['-m', 'venv', '.venv'], { cwd });
            await ioHelper.defaults.info(`Executing ${chalk.green('Installing dependencies...')}`);
            // Install dependencies in the virtual environment
            const pipPath = process.platform === 'win32' ? '.venv\\Scripts\\pip' : '.venv/bin/pip';
            await execute(ioHelper, pipPath, ['install', '-r', 'requirements.txt'], { cwd });
        }
        catch {
            await ioHelper.defaults.warn('Unable to create virtualenv or install dependencies automatically');
            await ioHelper.defaults.warn(`Please run '${python} -m venv .venv && .venv/bin/pip install -r requirements.txt'!`);
        }
    }
    else {
        await ioHelper.defaults.warn('No requirements.txt found. Please set up your Python environment manually.');
    }
}
async function postInstallGo(ioHelper, canUseNetwork, cwd) {
    if (!canUseNetwork) {
        await ioHelper.defaults.warn('Please run \'go mod tidy\'!');
        return;
    }
    await ioHelper.defaults.info(`Executing ${chalk.green('go mod tidy')}...`);
    try {
        await execute(ioHelper, 'go', ['mod', 'tidy'], { cwd });
    }
    catch (e) {
        await ioHelper.defaults.warn('\'go mod tidy\' failed: ' + (0, util_1.formatErrorMessage)(e));
    }
}
async function postInstallCSharp(ioHelper, canUseNetwork, cwd) {
    const solutionDir = path.join(cwd, 'src'); // the dotnet solution is inside the src dir
    const dotnetWarning = "Please run 'cd src && dotnet restore && dotnet build'!";
    if (!canUseNetwork) {
        await ioHelper.defaults.warn(dotnetWarning);
        return;
    }
    await ioHelper.defaults.info(`Executing ${chalk.green('dotnet restore')}...`);
    try {
        await execute(ioHelper, 'dotnet', ['restore'], { cwd: solutionDir });
        await ioHelper.defaults.info(`Executing ${chalk.green('dotnet build')}...`);
        await execute(ioHelper, 'dotnet', ['build'], { cwd: solutionDir });
    }
    catch (e) {
        await ioHelper.defaults.warn('Unable to restore/build .NET project: ' + (0, util_1.formatErrorMessage)(e));
        await ioHelper.defaults.warn(dotnetWarning);
    }
}
async function postInstallFSharp(ioHelper, canUseNetwork, cwd) {
    // F# uses the same build system as C#
    return postInstallCSharp(ioHelper, canUseNetwork, cwd);
}
/**
 * @param dir - a directory to be checked
 * @returns true if ``dir`` is within a git repository.
 */
async function isInGitRepository(dir) {
    while (true) {
        if (await fs.pathExists(path.join(dir, '.git'))) {
            return true;
        }
        if (isRoot(dir)) {
            return false;
        }
        dir = path.dirname(dir);
    }
}
/**
 * @param dir - a directory to be checked.
 * @returns true if ``dir`` is the root of a filesystem.
 */
function isRoot(dir) {
    return path.dirname(dir) === dir;
}
/**
 * Executes `command`. STDERR is emitted in real-time.
 *
 * If command exits with non-zero exit code, an exception is thrown and includes
 * the contents of STDOUT.
 *
 * @returns STDOUT (if successful).
 */
async function execute(ioHelper, cmd, args, { cwd }) {
    const child = childProcess.spawn(cmd, args, {
        cwd,
        shell: true,
        stdio: ['ignore', 'pipe', 'inherit'],
    });
    let stdout = '';
    child.stdout.on('data', (chunk) => (stdout += chunk.toString()));
    return new Promise((ok, fail) => {
        child.once('error', (err) => fail(err));
        child.once('exit', (status) => {
            if (status === 0) {
                return ok(stdout);
            }
            else {
                return fail(new toolkit_lib_1.ToolkitError(`${cmd} exited with status ${status}`));
            }
        });
    }).catch(async (err) => {
        await ioHelper.defaults.error(stdout);
        throw err;
    });
}
/**
 * Return the 'aws-cdk-lib' version we will init
 *
 * This has been built into the CLI at build time.
 */
async function loadInitVersions() {
    const initVersionFile = path.join((0, root_dir_1.cliRootDir)(), 'lib', 'init-templates', '.init-version.json');
    const contents = JSON.parse(await fs.readFile(initVersionFile, { encoding: 'utf-8' }));
    const ret = {
        'aws-cdk-lib': contents['aws-cdk-lib'],
        'constructs': contents.constructs,
        'aws-cdk': (0, version_1.versionNumber)(),
    };
    for (const [key, value] of Object.entries(ret)) {
        if (!value) {
            throw new toolkit_lib_1.ToolkitError(`Missing init version from ${initVersionFile}: ${key}`);
        }
    }
    return ret;
}
/**
 * Return the currently recommended flags for `aws-cdk-lib`.
 *
 * These have been built into the CLI at build time.
 */
async function currentlyRecommendedAwsCdkLibFlags() {
    const recommendedFlagsFile = path.join((0, root_dir_1.cliRootDir)(), 'lib', 'init-templates', '.recommended-feature-flags.json');
    return JSON.parse(await fs.readFile(recommendedFlagsFile, { encoding: 'utf-8' }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBZ0dBLDBCQXVDQztBQXliRCxnREE2Q0M7QUFVRCx3REFpQkM7QUFFRCx3REFXQztBQXVCRCwwREFjQztBQStURCxnRkFHQztBQTUvQkQsOENBQThDO0FBQzlDLDZCQUE2QjtBQUM3QixzREFBb0Q7QUFDcEQsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiw2Q0FBa0Q7QUFFbEQsaURBQWdEO0FBQ2hELCtDQUFrRDtBQUNsRCxxQ0FBeUY7QUFFekYsMENBQTJGO0FBQzNGLHVEQUEwRTtBQUUxRSx1REFBdUQsQ0FBQyxvQ0FBb0M7QUFDNUYsaUVBQWlFO0FBQ2pFLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN2QyxpRUFBaUU7QUFDakUsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBRXpDLE1BQU0sd0JBQXdCLEdBQUcsOEJBQW1CLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBZSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUF5RXRGOztHQUVHO0FBQ0ksS0FBSyxVQUFVLE9BQU8sQ0FBQyxPQUF1QjtJQUNuRCxNQUFNLHlCQUF5QixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFM0QsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUNsQyxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQztJQUNwRCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsWUFBWSxJQUFJLEtBQUssQ0FBQztJQUNuRCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUVqRCwyRUFBMkU7SUFDM0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxR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QUM7SUFDakgsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkUHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICdAYXdzLWNkay90b29sa2l0LWxpYic7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBpbnZva2VCdWlsdGluSG9va3MgfSBmcm9tICcuL2luaXQtaG9va3MnO1xuaW1wb3J0IHR5cGUgeyBJb0hlbHBlciB9IGZyb20gJy4uLy4uL2FwaS1wcml2YXRlJztcbmltcG9ydCB7IGNsaVJvb3REaXIgfSBmcm9tICcuLi8uLi9jbGkvcm9vdC1kaXInO1xuaW1wb3J0IHsgdmVyc2lvbk51bWJlciB9IGZyb20gJy4uLy4uL2NsaS92ZXJzaW9uJztcbmltcG9ydCB7IGNka0hvbWVEaXIsIGZvcm1hdEVycm9yTWVzc2FnZSwgcmFuZ2VGcm9tU2VtdmVyLCBzdHJpcENhcmV0IH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IExhbmd1YWdlSW5mbyB9IGZyb20gJy4uL2xhbmd1YWdlJztcbmltcG9ydCB7IGdldExhbmd1YWdlQWxpYXMsIGdldExhbmd1YWdlRXh0ZW5zaW9ucywgU1VQUE9SVEVEX0xBTkdVQUdFUyB9IGZyb20gJy4uL2xhbmd1YWdlJztcbmltcG9ydCB7IGdldFBtQ21kUHJlZml4LCB0eXBlIEpzUGFja2FnZU1hbmFnZXIgfSBmcm9tICcuL3BhY2thZ2UtbWFuYWdlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMgKi8gLy8gUGFja2FnZXMgZG9uJ3QgaGF2ZSBAdHlwZXMgbW9kdWxlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZSgnY2FtZWxjYXNlJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgZGVjYW1lbGl6ZSA9IHJlcXVpcmUoJ2RlY2FtZWxpemUnKTtcblxuY29uc3QgU1VQUE9SVEVEX0xBTkdVQUdFX05BTUVTID0gU1VQUE9SVEVEX0xBTkdVQUdFUy5tYXAoKGw6IExhbmd1YWdlSW5mbykgPT4gbC5uYW1lKTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGlJbml0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBuYW1lIHRvIGluaXRpYWxpemVcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgdGhlIHByb2plY3RcbiAgICogQGRlZmF1bHQgLSBPcHRpb25hbC9hdXRvLWRldGVjdGVkIGlmIHRlbXBsYXRlIHN1cHBvcnRzIG9ubHkgb25lIGxhbmd1YWdlLCBvdGhlcndpc2UgcmVxdWlyZWRcbiAgICovXG4gIHJlYWRvbmx5IGxhbmd1YWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBjYW5Vc2VOZXR3b3JrPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGdlbmVyYXRlT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIHJlYWRvbmx5IHdvcmtEaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgcHJvamVjdE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IG1pZ3JhdGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgYnVpbHQtaW4gQ0RLIHZlcnNpb25cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSBsaWJWZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIHRvIGEgbG9jYWwgY3VzdG9tIHRlbXBsYXRlIGRpcmVjdG9yeVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IGZyb21QYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIHRvIGEgc3BlY2lmaWMgdGVtcGxhdGUgd2l0aGluIGEgbXVsdGktdGVtcGxhdGUgcmVwb3NpdG9yeS5cbiAgICogVGhpcyBwYXJhbWV0ZXIgcmVxdWlyZXMgLS1mcm9tLXBhdGggdG8gYmUgc3BlY2lmaWVkLlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IHRlbXBsYXRlUGF0aD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UgZm9yIGluc3RhbGxpbmcgZGVwZW5kZW5jaWVzLiBPbmx5IGFwcGxpY2FibGUgZm9yIFR5cGVTY3JpcHQgYW5kIEphdmFTY3JpcHQgcHJvamVjdHMuXG4gICAqIEBkZWZhdWx0IC0gSWYgc3BlY2lmaWVkIGxhbmd1YWdlIGlzICd0eXBlc2NyaXB0JyBvciAnamF2YXNjcmlwdCcsICducG0nIGlzIHNlbGVjdGVkLiBPdGhlcndpc2UsIG5vIHBhY2thZ2UgbWFuYWdlciBpcyB1c2VkLlxuICAgKi9cbiAgcmVhZG9ubHkgcGFja2FnZU1hbmFnZXI/OiBKc1BhY2thZ2VNYW5hZ2VyO1xuXG4gIHJlYWRvbmx5IGlvSGVscGVyOiBJb0hlbHBlcjtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgQ0RLIHBhY2thZ2UgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGlJbml0KG9wdGlvbnM6IENsaUluaXRPcHRpb25zKSB7XG4gIGF3YWl0IGVuc3VyZVZhbGlkQ2xpSW5pdE9wdGlvbnMob3B0aW9ucywgb3B0aW9ucy5pb0hlbHBlcik7XG5cbiAgY29uc3QgaW9IZWxwZXIgPSBvcHRpb25zLmlvSGVscGVyO1xuICBjb25zdCBjYW5Vc2VOZXR3b3JrID0gb3B0aW9ucy5jYW5Vc2VOZXR3b3JrID8/IHRydWU7XG4gIGNvbnN0IGdlbmVyYXRlT25seSA9IG9wdGlvbnMuZ2VuZXJhdGVPbmx5ID8/IGZhbHNlO1xuICBjb25zdCB3b3JrRGlyID0gb3B0aW9ucy53b3JrRGlyID8/IHByb2Nlc3MuY3dkKCk7XG5cbiAgLy8gU2hvdyBhdmFpbGFibGUgdGVtcGxhdGVzIG9ubHkgaWYgbm8gZnJvbVBhdGgsIHR5cGUsIG9yIGxhbmd1YWdlIHByb3ZpZGVkXG4gIGlmICghb3B0aW9ucy5mcm9tUGF0aCAmJiAhb3B0aW9ucy50eXBlICYmICFvcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgYXdhaXQgcHJpbnRBdmFpbGFibGVUZW1wbGF0ZXMoaW9IZWxwZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFN0ZXAgMTogTG9hZCB0ZW1wbGF0ZVxuICBsZXQgdGVtcGxhdGU6IEluaXRUZW1wbGF0ZTtcbiAgaWYgKG9wdGlvbnMuZnJvbVBhdGgpIHtcbiAgICB0ZW1wbGF0ZSA9IGF3YWl0IGxvYWRMb2NhbFRlbXBsYXRlKG9wdGlvbnMuZnJvbVBhdGgsIG9wdGlvbnMudGVtcGxhdGVQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGF3YWl0IGxvYWRCdWlsdGluVGVtcGxhdGUoaW9IZWxwZXIsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5sYW5ndWFnZSk7XG4gIH1cblxuICAvLyBTdGVwIDI6IFJlc29sdmUgbGFuZ3VhZ2VcbiAgY29uc3QgbGFuZ3VhZ2UgPSBhd2FpdCByZXNvbHZlTGFuZ3VhZ2UoaW9IZWxwZXIsIHRlbXBsYXRlLCBvcHRpb25zLmxhbmd1YWdlLCBvcHRpb25zLnR5cGUpO1xuXG4gIC8vIFN0ZXAgMzogSW5pdGlhbGl6ZSBwcm9qZWN0IGZvbGxvd2luZyBzdGFuZGFyZCBwcm9jZXNzXG4gIGF3YWl0IGluaXRpYWxpemVQcm9qZWN0KFxuICAgIGlvSGVscGVyLFxuICAgIHRlbXBsYXRlLFxuICAgIGxhbmd1YWdlLFxuICAgIGNhblVzZU5ldHdvcmssXG4gICAgZ2VuZXJhdGVPbmx5LFxuICAgIHdvcmtEaXIsXG4gICAgb3B0aW9ucy5wcm9qZWN0TmFtZSxcbiAgICBvcHRpb25zLnN0YWNrTmFtZSxcbiAgICBvcHRpb25zLm1pZ3JhdGUsXG4gICAgb3B0aW9ucy5saWJWZXJzaW9uLFxuICAgIG9wdGlvbnMucGFja2FnZU1hbmFnZXIsXG4gICk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgQ0xJIGluaXQgb3B0aW9ucyBhbmQgaGFuZGxlIGludmFsaWQgb3IgaW5jb21wYXRpYmxlIG9wdGlvbiBjb21iaW5hdGlvbnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5zdXJlVmFsaWRDbGlJbml0T3B0aW9ucyhvcHRpb25zOiBDbGlJbml0T3B0aW9ucywgaW9IZWxwZXI6IElvSGVscGVyKSB7XG4gIGlmIChvcHRpb25zLnBhY2thZ2VNYW5hZ2VyICYmICFbJ2phdmFzY3JpcHQnLCAndHlwZXNjcmlwdCddLmluY2x1ZGVzKG9wdGlvbnMubGFuZ3VhZ2UgPz8gJycpKSB7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybihgLS1wYWNrYWdlLW1hbmFnZXIgb3B0aW9uIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgSmF2YVNjcmlwdCBhbmQgVHlwZVNjcmlwdCBwcm9qZWN0cy4gSWdub3JpbmcgdGhlIHByb3ZpZGVkIHZhbHVlOiAke29wdGlvbnMucGFja2FnZU1hbmFnZXJ9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGEgbG9jYWwgY3VzdG9tIHRlbXBsYXRlIGZyb20gZmlsZSBzeXN0ZW0gcGF0aFxuICogQHBhcmFtIGZyb21QYXRoIC0gUGF0aCB0byB0aGUgbG9jYWwgdGVtcGxhdGUgZGlyZWN0b3J5IG9yIG11bHRpLXRlbXBsYXRlIHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB0ZW1wbGF0ZVBhdGggLSBPcHRpb25hbCBwYXRoIHRvIGEgc3BlY2lmaWMgdGVtcGxhdGUgd2l0aGluIGEgbXVsdGktdGVtcGxhdGUgcmVwb3NpdG9yeVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGxvYWRlZCBJbml0VGVtcGxhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZExvY2FsVGVtcGxhdGUoZnJvbVBhdGg6IHN0cmluZywgdGVtcGxhdGVQYXRoPzogc3RyaW5nKTogUHJvbWlzZTxJbml0VGVtcGxhdGU+IHtcbiAgdHJ5IHtcbiAgICBsZXQgYWN0dWFsVGVtcGxhdGVQYXRoID0gZnJvbVBhdGg7XG5cbiAgICAvLyBJZiB0ZW1wbGF0ZVBhdGggaXMgcHJvdmlkZWQsIGl0J3MgYSBtdWx0aS10ZW1wbGF0ZSByZXBvc2l0b3J5XG4gICAgaWYgKHRlbXBsYXRlUGF0aCkge1xuICAgICAgYWN0dWFsVGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGZyb21QYXRoLCB0ZW1wbGF0ZVBhdGgpO1xuXG4gICAgICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoYWN0dWFsVGVtcGxhdGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUZW1wbGF0ZSBwYXRoIGRvZXMgbm90IGV4aXN0OiAke2FjdHVhbFRlbXBsYXRlUGF0aH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IEluaXRUZW1wbGF0ZS5mcm9tUGF0aChhY3R1YWxUZW1wbGF0ZVBhdGgpO1xuXG4gICAgaWYgKHRlbXBsYXRlLmxhbmd1YWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbWlnaHQgYmUgYSBtdWx0aS10ZW1wbGF0ZSByZXBvc2l0b3J5XG4gICAgICBpZiAoIXRlbXBsYXRlUGF0aCkge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVUZW1wbGF0ZXMgPSBhd2FpdCBmaW5kUG90ZW50aWFsVGVtcGxhdGVzKGZyb21QYXRoKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZVRlbXBsYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICAgICdVc2UgLS10ZW1wbGF0ZS1wYXRoIHRvIHNwZWNpZnkgd2hpY2ggdGVtcGxhdGUgdG8gdXNlLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQ3VzdG9tIHRlbXBsYXRlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbGFuZ3VhZ2UgZGlyZWN0b3J5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc3QgZGlzcGxheVBhdGggPSB0ZW1wbGF0ZVBhdGggPyBgJHtmcm9tUGF0aH0vJHt0ZW1wbGF0ZVBhdGh9YCA6IGZyb21QYXRoO1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYEZhaWxlZCB0byBsb2FkIHRlbXBsYXRlIGZyb20gcGF0aDogJHtkaXNwbGF5UGF0aH0uICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYSBidWlsdC1pbiB0ZW1wbGF0ZSBieSBuYW1lXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCdWlsdGluVGVtcGxhdGUoaW9IZWxwZXI6IElvSGVscGVyLCB0eXBlPzogc3RyaW5nLCBsYW5ndWFnZT86IHN0cmluZyk6IFByb21pc2U8SW5pdFRlbXBsYXRlPiB7XG4gIGNvbnN0IHRlbXBsYXRlVHlwZSA9IHR5cGUgfHwgJ2RlZmF1bHQnOyAvLyBcImRlZmF1bHRcIiBpcyB0aGUgZGVmYXVsdCB0eXBlIChhbmQgbWFwcyB0byBcImFwcFwiKVxuXG4gIGNvbnN0IHRlbXBsYXRlID0gKGF3YWl0IGF2YWlsYWJsZUluaXRUZW1wbGF0ZXMoKSkuZmluZCgodCkgPT4gdC5oYXNOYW1lKHRlbXBsYXRlVHlwZSkpO1xuICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgYXdhaXQgcHJpbnRBdmFpbGFibGVUZW1wbGF0ZXMoaW9IZWxwZXIsIGxhbmd1YWdlKTtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbmtub3duIGluaXQgdGVtcGxhdGU6ICR7dGVtcGxhdGVUeXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlIGZvciB0aGUgdGVtcGxhdGVcbiAqIEBwYXJhbSBpb0hlbHBlciAtIElPIGhlbHBlciBmb3IgdXNlciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHRlbXBsYXRlIC0gVGhlIHRlbXBsYXRlIHRvIHJlc29sdmUgbGFuZ3VhZ2UgZm9yXG4gKiBAcGFyYW0gcmVxdWVzdGVkTGFuZ3VhZ2UgLSBVc2VyLXJlcXVlc3RlZCBsYW5ndWFnZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0ZW1wbGF0ZSB0eXBlIG5hbWUgZm9yIG1lc3NhZ2VzXG4gKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzZWxlY3RlZCBsYW5ndWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTGFuZ3VhZ2UoaW9IZWxwZXI6IElvSGVscGVyLCB0ZW1wbGF0ZTogSW5pdFRlbXBsYXRlLCByZXF1ZXN0ZWRMYW5ndWFnZT86IHN0cmluZywgdHlwZT86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgIGlmIChyZXF1ZXN0ZWRMYW5ndWFnZSkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RlZExhbmd1YWdlO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUubGFuZ3VhZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgdGVtcGxhdGVMYW5ndWFnZSA9IHRlbXBsYXRlLmxhbmd1YWdlc1swXTtcbiAgICAgIC8vIE9ubHkgc2hvdyBhdXRvLWRldGVjdGlvbiBtZXNzYWdlIGZvciBidWlsdC1pbiB0ZW1wbGF0ZXNcbiAgICAgIGlmICh0ZW1wbGF0ZS50ZW1wbGF0ZVR5cGUgIT09IFRlbXBsYXRlVHlwZS5DVVNUT00pIHtcbiAgICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybihcbiAgICAgICAgICBgTm8gLS1sYW5ndWFnZSB3YXMgcHJvdmlkZWQsIGJ1dCAnJHt0eXBlIHx8IHRlbXBsYXRlLm5hbWV9JyBzdXBwb3J0cyBvbmx5ICcke3RlbXBsYXRlTGFuZ3VhZ2V9Jywgc28gZGVmYXVsdGluZyB0byAtLWxhbmd1YWdlPSR7dGVtcGxhdGVMYW5ndWFnZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlTGFuZ3VhZ2U7XG4gICAgfVxuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oXG4gICAgICBgQXZhaWxhYmxlIGxhbmd1YWdlcyBmb3IgJHtjaGFsay5ncmVlbih0eXBlIHx8IHRlbXBsYXRlLm5hbWUpfTogJHt0ZW1wbGF0ZS5sYW5ndWFnZXMubWFwKChsKSA9PiBjaGFsay5ibHVlKGwpKS5qb2luKCcsICcpfWAsXG4gICAgKTtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdObyBsYW5ndWFnZSB3YXMgc2VsZWN0ZWQnKTtcbiAgfSkoKTtcbn1cblxuLyoqXG4gKiBGaW5kIHBvdGVudGlhbCB0ZW1wbGF0ZSBkaXJlY3RvcmllcyBpbiBhIG11bHRpLXRlbXBsYXRlIHJlcG9zaXRvcnlcbiAqIEBwYXJhbSByZXBvc2l0b3J5UGF0aCAtIFBhdGggdG8gdGhlIHJlcG9zaXRvcnkgcm9vdFxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgcG90ZW50aWFsIHRlbXBsYXRlIGRpcmVjdG9yeSBuYW1lc1xuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kUG90ZW50aWFsVGVtcGxhdGVzKHJlcG9zaXRvcnlQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHJlcG9zaXRvcnlQYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgY29uc3QgdGVtcGxhdGVWYWxpZGF0aW9uUHJvbWlzZXMgPSBlbnRyaWVzXG4gICAgLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5pc0RpcmVjdG9yeSgpICYmICFlbnRyeS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSlcbiAgICAubWFwKGFzeW5jIChlbnRyeSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKHJlcG9zaXRvcnlQYXRoLCBlbnRyeS5uYW1lKTtcbiAgICAgICAgY29uc3QgeyBsYW5ndWFnZXMgfSA9IGF3YWl0IGdldExhbmd1YWdlRGlyZWN0b3JpZXModGVtcGxhdGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPiAwID8gZW50cnkubmFtZSA6IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIC8vIElmIHdlIGNhbid0IHJlYWQgYSBzcGVjaWZpYyB0ZW1wbGF0ZSBkaXJlY3RvcnksIHNraXAgaXQgYnV0IGRvbid0IGZhaWwgdGhlIGVudGlyZSBvcGVyYXRpb25cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtICovIC8vIExpbWl0ZWQgdG8gZGlyZWN0b3J5IGVudHJpZXNcbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZW1wbGF0ZVZhbGlkYXRpb25Qcm9taXNlcyk7XG4gIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0cy5maWx0ZXIoKHRlbXBsYXRlTmFtZSk6IHRlbXBsYXRlTmFtZSBpcyBzdHJpbmcgPT4gdGVtcGxhdGVOYW1lICE9PSBudWxsKTtcbn1cblxuLyoqXG4gKiBHZXQgdmFsaWQgQ0RLIGxhbmd1YWdlIGRpcmVjdG9yaWVzIGZyb20gYSB0ZW1wbGF0ZSBwYXRoXG4gKiBAcGFyYW0gdGVtcGxhdGVQYXRoIC0gUGF0aCB0byB0aGUgdGVtcGxhdGUgZGlyZWN0b3J5XG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2UgbmFtZXNcbiAqL1xuLyoqXG4gKiBHZXQgdmFsaWQgQ0RLIGxhbmd1YWdlIGRpcmVjdG9yaWVzIGZyb20gYSB0ZW1wbGF0ZSBwYXRoXG4gKiBAcGFyYW0gdGVtcGxhdGVQYXRoIC0gUGF0aCB0byB0aGUgdGVtcGxhdGUgZGlyZWN0b3J5XG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2UgbmFtZXMgYW5kIGRpcmVjdG9yeSBlbnRyaWVzXG4gKiBAdGhyb3dzIFRvb2xraXRFcnJvciBpZiBkaXJlY3RvcnkgY2Fubm90IGJlIHJlYWQgb3IgdmFsaWRhdGVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExhbmd1YWdlRGlyZWN0b3JpZXModGVtcGxhdGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgbGFuZ3VhZ2VzOiBzdHJpbmdbXTsgZW50cmllczogZnMuRGlyZW50W10gfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHRlbXBsYXRlUGF0aCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgbGFuZ3VhZ2VWYWxpZGF0aW9uUHJvbWlzZXMgPSBlbnRyaWVzXG4gICAgICAuZmlsdGVyKGRpcmVjdG9yeUVudHJ5ID0+IGRpcmVjdG9yeUVudHJ5LmlzRGlyZWN0b3J5KCkgJiYgU1VQUE9SVEVEX0xBTkdVQUdFX05BTUVTLmluY2x1ZGVzKGRpcmVjdG9yeUVudHJ5Lm5hbWUpKVxuICAgICAgLm1hcChhc3luYyAoZGlyZWN0b3J5RW50cnkpID0+IHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VEaXJlY3RvcnlQYXRoID0gcGF0aC5qb2luKHRlbXBsYXRlUGF0aCwgZGlyZWN0b3J5RW50cnkubmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaGFzVmFsaWRMYW5ndWFnZUZpbGVzID0gYXdhaXQgaGFzTGFuZ3VhZ2VGaWxlcyhsYW5ndWFnZURpcmVjdG9yeVBhdGgsIGdldExhbmd1YWdlRXh0ZW5zaW9ucyhkaXJlY3RvcnlFbnRyeS5uYW1lKSk7XG4gICAgICAgICAgcmV0dXJuIGhhc1ZhbGlkTGFuZ3VhZ2VGaWxlcyA/IGRpcmVjdG9yeUVudHJ5Lm5hbWUgOiBudWxsO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQ2Fubm90IHJlYWQgbGFuZ3VhZ2UgZGlyZWN0b3J5ICcke2RpcmVjdG9yeUVudHJ5Lm5hbWV9JzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbSAqLyAvLyBMaW1pdGVkIHRvIHN1cHBvcnRlZCBDREsgbGFuZ3VhZ2VzICg3IG1heClcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGxhbmd1YWdlVmFsaWRhdGlvblByb21pc2VzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2VzOiB2YWxpZGF0aW9uUmVzdWx0cy5maWx0ZXIoKGxhbmd1YWdlTmFtZSk6IGxhbmd1YWdlTmFtZSBpcyBzdHJpbmcgPT4gbGFuZ3VhZ2VOYW1lICE9PSBudWxsKSxcbiAgICAgIGVudHJpZXMsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYENhbm5vdCByZWFkIHRlbXBsYXRlIGRpcmVjdG9yeSAnJHt0ZW1wbGF0ZVBhdGh9JzogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59XG5cbi8qKlxuICogSXRlcmF0aXZlbHkgY2hlY2sgaWYgYSBkaXJlY3RvcnkgY29udGFpbnMgZmlsZXMgd2l0aCB0aGUgc3BlY2lmaWVkIGV4dGVuc2lvbnNcbiAqIEBwYXJhbSBkaXJlY3RvcnlQYXRoIC0gUGF0aCB0byBzZWFyY2ggZm9yIGxhbmd1YWdlIGZpbGVzXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyAtIEFycmF5IG9mIGZpbGUgZXh0ZW5zaW9ucyB0byBsb29rIGZvclxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiBsYW5ndWFnZSBmaWxlcyBhcmUgZm91bmRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFzTGFuZ3VhZ2VGaWxlcyhkaXJlY3RvcnlQYXRoOiBzdHJpbmcsIGV4dGVuc2lvbnM6IHN0cmluZ1tdKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGRpcnNUb0NoZWNrID0gW2RpcmVjdG9yeVBhdGhdO1xuXG4gIHdoaWxlIChkaXJzVG9DaGVjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VycmVudERpciA9IGRpcnNUb0NoZWNrLnBvcCgpITtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihjdXJyZW50RGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkuaXNGaWxlKCkgJiYgZXh0ZW5zaW9ucy5zb21lKGV4dCA9PiBlbnRyeS5uYW1lLmVuZHNXaXRoKGV4dCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGRpcnNUb0NoZWNrLnB1c2gocGF0aC5qb2luKGN1cnJlbnREaXIsIGVudHJ5Lm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBQeXRob24gZXhlY3V0YWJsZSBmb3IgdGhpcyBPU1xuICogQHJldHVybnMgVGhlIFB5dGhvbiBleGVjdXRhYmxlIG5hbWUgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtXG4gKi9cbmZ1bmN0aW9uIHB5dGhvbkV4ZWN1dGFibGUoKSB7XG4gIGxldCBweXRob24gPSAncHl0aG9uMyc7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgcHl0aG9uID0gJ3B5dGhvbic7XG4gIH1cbiAgcmV0dXJuIHB5dGhvbjtcbn1cbmNvbnN0IElORk9fRE9UX0pTT04gPSAnaW5mby5qc29uJztcblxuaW50ZXJmYWNlIFRlbXBsYXRlSW5pdEluZm8ge1xuICByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICByZWFkb25seSBhbGlhc2VzPzogc3RyaW5nW107XG59XG5cbmVudW0gVGVtcGxhdGVUeXBlIHtcbiAgQlVJTFRfSU4gPSAnYnVpbHRpbicsXG4gIENVU1RPTSA9ICdjdXN0b20nLFxufVxuXG5leHBvcnQgY2xhc3MgSW5pdFRlbXBsYXRlIHtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBmcm9tTmFtZSh0ZW1wbGF0ZXNEaXI6IHN0cmluZywgbmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSBwYXRoLmpvaW4odGVtcGxhdGVzRGlyLCBuYW1lKTtcbiAgICBjb25zdCBsYW5ndWFnZXMgPSBhd2FpdCBsaXN0RGlyZWN0b3J5KGJhc2VQYXRoKTtcbiAgICBjb25zdCBpbml0SW5mbyA9IGF3YWl0IGZzLnJlYWRKc29uKHBhdGguam9pbihiYXNlUGF0aCwgSU5GT19ET1RfSlNPTikpO1xuICAgIHJldHVybiBuZXcgSW5pdFRlbXBsYXRlKGJhc2VQYXRoLCBuYW1lLCBsYW5ndWFnZXMsIGluaXRJbmZvLCBUZW1wbGF0ZVR5cGUuQlVJTFRfSU4pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBmcm9tUGF0aCh0ZW1wbGF0ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcGF0aC5yZXNvbHZlKHRlbXBsYXRlUGF0aCk7XG5cbiAgICBpZiAoIWF3YWl0IGZzLnBhdGhFeGlzdHMoYmFzZVBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUZW1wbGF0ZSBwYXRoIGRvZXMgbm90IGV4aXN0OiAke2Jhc2VQYXRofWApO1xuICAgIH1cblxuICAgIGxldCB0ZW1wbGF0ZVNvdXJjZVBhdGggPSBiYXNlUGF0aDtcbiAgICBsZXQgeyBsYW5ndWFnZXMsIGVudHJpZXMgfSA9IGF3YWl0IGdldExhbmd1YWdlRGlyZWN0b3JpZXMoYmFzZVBhdGgpO1xuXG4gICAgaWYgKGxhbmd1YWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGxhbmd1YWdlRGlycyA9IGVudHJpZXMuZmlsdGVyKGVudHJ5ID0+XG4gICAgICAgIGVudHJ5LmlzRGlyZWN0b3J5KCkgJiZcbiAgICAgICAgU1VQUE9SVEVEX0xBTkdVQUdFX05BTUVTLmluY2x1ZGVzKGVudHJ5Lm5hbWUpLFxuICAgICAgKTtcblxuICAgICAgaWYgKGxhbmd1YWdlRGlycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgbGFuZ3VhZ2UgZGlyZWN0b3J5IGNvbnRhaW5zIGFwcHJvcHJpYXRlIGZpbGVzXG4gICAgICAgIGNvbnN0IGxhbmdEaXIgPSBsYW5ndWFnZURpcnNbMF0ubmFtZTtcbiAgICAgICAgdGVtcGxhdGVTb3VyY2VQYXRoID0gcGF0aC5qb2luKGJhc2VQYXRoLCBsYW5nRGlyKTtcbiAgICAgICAgY29uc3QgaGFzVmFsaWRGaWxlcyA9IGF3YWl0IGhhc0xhbmd1YWdlRmlsZXModGVtcGxhdGVTb3VyY2VQYXRoLCBnZXRMYW5ndWFnZUV4dGVuc2lvbnMobGFuZ0RpcikpO1xuXG4gICAgICAgIGlmICghaGFzVmFsaWRGaWxlcykge1xuICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbGFuZ3VhZ2UgZGlyZWN0b3J5IGJ1dCBpdCBkb2Vzbid0IGNvbnRhaW4gdmFsaWQgZmlsZXMsIHdlIHNob3VsZCBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBGb3VuZCAnJHtsYW5nRGlyfScgZGlyZWN0b3J5IGJ1dCBpdCBkb2Vzbid0IGNvbnRhaW4gdGhlIGV4cGVjdGVkIGxhbmd1YWdlIGZpbGVzLiBFbnN1cmUgdGhlIHRlbXBsYXRlIGNvbnRhaW5zICR7bGFuZ0Rpcn0gc291cmNlIGZpbGVzLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHBhdGguYmFzZW5hbWUoYmFzZVBhdGgpO1xuXG4gICAgcmV0dXJuIG5ldyBJbml0VGVtcGxhdGUodGVtcGxhdGVTb3VyY2VQYXRoLCBuYW1lLCBsYW5ndWFnZXMsIG51bGwsIFRlbXBsYXRlVHlwZS5DVVNUT00pO1xuICB9XG5cbiAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgYWxpYXNlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwdWJsaWMgcmVhZG9ubHkgdGVtcGxhdGVUeXBlOiBUZW1wbGF0ZVR5cGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBiYXNlUGF0aDogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IGxhbmd1YWdlczogc3RyaW5nW10sXG4gICAgaW5pdEluZm86IFRlbXBsYXRlSW5pdEluZm8gfCBudWxsLFxuICAgIHRlbXBsYXRlVHlwZTogVGVtcGxhdGVUeXBlLFxuICApIHtcbiAgICB0aGlzLnRlbXBsYXRlVHlwZSA9IHRlbXBsYXRlVHlwZTtcbiAgICAvLyBPbmx5IGJ1aWx0LWluIHRlbXBsYXRlcyBoYXZlIGRlc2NyaXB0aW9ucyBhbmQgYWxpYXNlcyBmcm9tIGluZm8uanNvblxuICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09IFRlbXBsYXRlVHlwZS5CVUlMVF9JTiAmJiBpbml0SW5mbykge1xuICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGluaXRJbmZvLmRlc2NyaXB0aW9uO1xuICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBpbml0SW5mby5hbGlhc2VzIHx8IFtdKSB7XG4gICAgICAgIHRoaXMuYWxpYXNlcy5hZGQoYWxpYXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIHRoYXQgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBgYHRydWVgYCBpZiBgYG5hbWVgYCBpcyB0aGUgbmFtZSBvZiB0aGlzIHRlbXBsYXRlIG9yIGFuIGFsaWFzIG9mIGl0LlxuICAgKi9cbiAgcHVibGljIGhhc05hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hbWUgPT09IHRoaXMubmFtZSB8fCB0aGlzLmFsaWFzZXMuaGFzKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBgYEluaXRUZW1wbGF0ZWBgIGZvciBhIGdpdmVuIGxhbmd1YWdlIHRvIGEgc3BlY2lmaWVkIGZvbGRlci5cbiAgICpcbiAgICogQHBhcmFtIGxhbmd1YWdlIC0gdGhlIGxhbmd1YWdlIHRvIGluc3RhbnRpYXRlIHRoaXMgdGVtcGxhdGUgd2l0aFxuICAgKiBAcGFyYW0gdGFyZ2V0RGlyZWN0b3J5IC0gdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgdGVtcGxhdGUgaXMgdG8gYmUgaW5zdGFudGlhdGVkIGludG9cbiAgICogQHBhcmFtIHN0YWNrTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byBjcmVhdGVcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBsaWJWZXJzaW9uIC0gdGhlIHZlcnNpb24gb2YgdGhlIENESyBsaWJyYXJ5IHRvIHVzZVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbnN0YWxsKFxuICAgIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgICBsYW5ndWFnZTogc3RyaW5nLFxuICAgIHRhcmdldERpcmVjdG9yeTogc3RyaW5nLFxuICAgIHByb2plY3ROYW1lPzogc3RyaW5nLFxuICAgIHN0YWNrTmFtZT86IHN0cmluZyxcbiAgICBsaWJWZXJzaW9uPzogc3RyaW5nLFxuICAgIHBhY2thZ2VNYW5hZ2VyPzogSnNQYWNrYWdlTWFuYWdlcixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMubGFuZ3VhZ2VzLmluZGV4T2YobGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuZXJyb3IoXG4gICAgICAgIGBUaGUgJHtjaGFsay5ibHVlKGxhbmd1YWdlKX0gbGFuZ3VhZ2UgaXMgbm90IHN1cHBvcnRlZCBmb3IgJHtjaGFsay5ncmVlbih0aGlzLm5hbWUpfSBgICtcbiAgICAgICAgICBgKGl0IHN1cHBvcnRzOiAke3RoaXMubGFuZ3VhZ2VzLm1hcCgobCkgPT4gY2hhbGsuYmx1ZShsKSkuam9pbignLCAnKX0pYCxcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbnN1cHBvcnRlZCBsYW5ndWFnZTogJHtsYW5ndWFnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9qZWN0SW5mbzogUHJvamVjdEluZm8gPSB7XG4gICAgICBuYW1lOiBwcm9qZWN0TmFtZSA/IGRlY2FtZWxpemUocHJvamVjdE5hbWUpIDogZGVjYW1lbGl6ZShwYXRoLmJhc2VuYW1lKHBhdGgucmVzb2x2ZSh0YXJnZXREaXJlY3RvcnkpKSksXG4gICAgICBzdGFja05hbWUsXG4gICAgICB2ZXJzaW9uczogYXdhaXQgbG9hZEluaXRWZXJzaW9ucygpLFxuICAgIH07XG5cbiAgICBpZiAobGliVmVyc2lvbikge1xuICAgICAgcHJvamVjdEluZm8udmVyc2lvbnNbJ2F3cy1jZGstbGliJ10gPSBsaWJWZXJzaW9uO1xuICAgIH1cblxuICAgIGxldCBzb3VyY2VEaXJlY3RvcnkgPSBwYXRoLmpvaW4odGhpcy5iYXNlUGF0aCwgbGFuZ3VhZ2UpO1xuXG4gICAgLy8gRm9yIGF1dG8tZGV0ZWN0ZWQgc2luZ2xlIGxhbmd1YWdlIHRlbXBsYXRlcywgdXNlIGJhc2VQYXRoIGRpcmVjdGx5XG4gICAgaWYgKHRoaXMudGVtcGxhdGVUeXBlID09PSBUZW1wbGF0ZVR5cGUuQ1VTVE9NICYmIHRoaXMubGFuZ3VhZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBwYXRoLmJhc2VuYW1lKHRoaXMuYmFzZVBhdGgpID09PSBsYW5ndWFnZSkge1xuICAgICAgc291cmNlRGlyZWN0b3J5ID0gdGhpcy5iYXNlUGF0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZW1wbGF0ZVR5cGUgPT09IFRlbXBsYXRlVHlwZS5DVVNUT00pIHtcbiAgICAgIC8vIEZvciBjdXN0b20gdGVtcGxhdGVzLCBjb3B5IGZpbGVzIHdpdGhvdXQgcHJvY2Vzc2luZyBwbGFjZWhvbGRlcnNcbiAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbEZpbGVzV2l0aG91dFByb2Nlc3Npbmcoc291cmNlRGlyZWN0b3J5LCB0YXJnZXREaXJlY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYnVpbHQtaW4gdGVtcGxhdGVzLCBwcm9jZXNzIHBsYWNlaG9sZGVycyBhcyB1c3VhbFxuICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsRmlsZXMoc291cmNlRGlyZWN0b3J5LCB0YXJnZXREaXJlY3RvcnksIGxhbmd1YWdlLCBwcm9qZWN0SW5mbywgcGFja2FnZU1hbmFnZXIpO1xuICAgICAgYXdhaXQgdGhpcy5hcHBseUZ1dHVyZUZsYWdzKHRhcmdldERpcmVjdG9yeSk7XG4gICAgICBhd2FpdCBpbnZva2VCdWlsdGluSG9va3MoXG4gICAgICAgIGlvSGVscGVyLFxuICAgICAgICB7IHRhcmdldERpcmVjdG9yeSwgbGFuZ3VhZ2UsIHRlbXBsYXRlTmFtZTogdGhpcy5uYW1lIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzdWJzdGl0dXRlUGxhY2Vob2xkZXJzSW46IGFzeW5jICguLi5maWxlTmFtZXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlUHJvY2Vzc2luZ1Byb21pc2VzID0gZmlsZU5hbWVzLm1hcChhc3luYyAoZmlsZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4odGFyZ2V0RGlyZWN0b3J5LCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgZnMucmVhZEZpbGUoZnVsbFBhdGgsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShmdWxsUGF0aCwgZXhwYW5kUGxhY2Vob2xkZXJzKHRlbXBsYXRlLCBsYW5ndWFnZSwgcHJvamVjdEluZm8sIHBhY2thZ2VNYW5hZ2VyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbSAqLyAvLyBQcm9jZXNzaW5nIGEgc21hbGwsIGtub3duIHNldCBvZiB0ZW1wbGF0ZSBmaWxlc1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZmlsZVByb2Nlc3NpbmdQcm9taXNlcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogKHBoOiBzdHJpbmcpID0+IGV4cGFuZFBsYWNlaG9sZGVycyhgJSR7cGh9JWAsIGxhbmd1YWdlLCBwcm9qZWN0SW5mbywgcGFja2FnZU1hbmFnZXIpLFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluc3RhbGxGaWxlcyhcbiAgICBzb3VyY2VEaXJlY3Rvcnk6IHN0cmluZyxcbiAgICB0YXJnZXREaXJlY3Rvcnk6IHN0cmluZyxcbiAgICBsYW5ndWFnZTogc3RyaW5nLFxuICAgIHByb2plY3Q6IFByb2plY3RJbmZvLFxuICAgIHBhY2thZ2VNYW5hZ2VyPzogSnNQYWNrYWdlTWFuYWdlcixcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGF3YWl0IGZzLnJlYWRkaXIoc291cmNlRGlyZWN0b3J5KSkge1xuICAgICAgY29uc3QgZnJvbUZpbGUgPSBwYXRoLmpvaW4oc291cmNlRGlyZWN0b3J5LCBmaWxlKTtcbiAgICAgIGNvbnN0IHRvRmlsZSA9IHBhdGguam9pbih0YXJnZXREaXJlY3RvcnksIGV4cGFuZFBsYWNlaG9sZGVycyhmaWxlLCBsYW5ndWFnZSwgcHJvamVjdCwgcGFja2FnZU1hbmFnZXIpKTtcbiAgICAgIGlmICgoYXdhaXQgZnMuc3RhdChmcm9tRmlsZSkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgYXdhaXQgZnMubWtkaXIodG9GaWxlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsRmlsZXMoZnJvbUZpbGUsIHRvRmlsZSwgbGFuZ3VhZ2UsIHByb2plY3QsIHBhY2thZ2VNYW5hZ2VyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGZpbGUubWF0Y2goL14uKlxcLnRlbXBsYXRlXFwuW14uXSskLykpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsUHJvY2Vzc2VkKGZyb21GaWxlLCB0b0ZpbGUucmVwbGFjZSgvXFwudGVtcGxhdGUoXFwuW14uXSspJC8sICckMScpLCBsYW5ndWFnZSwgcHJvamVjdCwgcGFja2FnZU1hbmFnZXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5tYXRjaCgvXi4qXFwuaG9va1xcLihkLik/W14uXSskLykpIHtcbiAgICAgICAgLy8gSWdub3JlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZnMuY29weShmcm9tRmlsZSwgdG9GaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluc3RhbGxQcm9jZXNzZWQoXG4gICAgdGVtcGxhdGVQYXRoOiBzdHJpbmcsXG4gICAgdG9GaWxlOiBzdHJpbmcsXG4gICAgbGFuZ3VhZ2U6IHN0cmluZyxcbiAgICBwcm9qZWN0OiBQcm9qZWN0SW5mbyxcbiAgICBwYWNrYWdlTWFuYWdlcj86IEpzUGFja2FnZU1hbmFnZXIsXG4gICkge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgZnMucmVhZEZpbGUodGVtcGxhdGVQYXRoLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0b0ZpbGUsIGV4cGFuZFBsYWNlaG9sZGVycyh0ZW1wbGF0ZSwgbGFuZ3VhZ2UsIHByb2plY3QsIHBhY2thZ2VNYW5hZ2VyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29weSB0ZW1wbGF0ZSBmaWxlcyB3aXRob3V0IHByb2Nlc3NpbmcgcGxhY2Vob2xkZXJzIChmb3IgY3VzdG9tIHRlbXBsYXRlcylcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zdGFsbEZpbGVzV2l0aG91dFByb2Nlc3Npbmcoc291cmNlRGlyZWN0b3J5OiBzdHJpbmcsIHRhcmdldERpcmVjdG9yeTogc3RyaW5nKSB7XG4gICAgYXdhaXQgZnMuY29weShzb3VyY2VEaXJlY3RvcnksIHRhcmdldERpcmVjdG9yeSwge1xuICAgICAgZmlsdGVyOiAoc3JjOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHNyYyk7XG4gICAgICAgIHJldHVybiAhZmlsZW5hbWUubWF0Y2goL14uKlxcLmhvb2tcXC4oZC4pP1teLl0rJC8pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNvbnRleHQgdmFyaWFibGVzIHRvIGBjZGsuanNvbmAgaW4gdGhlIGdlbmVyYXRlZCBwcm9qZWN0IGRpcmVjdG9yeSB0b1xuICAgKiBlbmFibGUgZnV0dXJlIGJlaGF2aW9yIGZvciBuZXcgcHJvamVjdHMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGFwcGx5RnV0dXJlRmxhZ3MocHJvamVjdERpcjogc3RyaW5nKSB7XG4gICAgY29uc3QgY2RrSnNvbiA9IHBhdGguam9pbihwcm9qZWN0RGlyLCAnY2RrLmpzb24nKTtcbiAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGNka0pzb24pKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGZzLnJlYWRKc29uKGNka0pzb24pO1xuICAgIGNvbmZpZy5jb250ZXh0ID0ge1xuICAgICAgLi4uY29uZmlnLmNvbnRleHQsXG4gICAgICAuLi5hd2FpdCBjdXJyZW50bHlSZWNvbW1lbmRlZEF3c0Nka0xpYkZsYWdzKCksXG4gICAgfTtcblxuICAgIGF3YWl0IGZzLndyaXRlSnNvbihjZGtKc29uLCBjb25maWcsIHsgc3BhY2VzOiAyIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFkZE1pZ3JhdGVDb250ZXh0KHByb2plY3REaXI6IHN0cmluZykge1xuICAgIGNvbnN0IGNka0pzb24gPSBwYXRoLmpvaW4ocHJvamVjdERpciwgJ2Nkay5qc29uJyk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhjZGtKc29uKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCBmcy5yZWFkSnNvbihjZGtKc29uKTtcbiAgICBjb25maWcuY29udGV4dCA9IHtcbiAgICAgIC4uLmNvbmZpZy5jb250ZXh0LFxuICAgICAgJ2Nkay1taWdyYXRlJzogdHJ1ZSxcbiAgICB9O1xuXG4gICAgYXdhaXQgZnMud3JpdGVKc29uKGNka0pzb24sIGNvbmZpZywgeyBzcGFjZXM6IDIgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFBsYWNlaG9sZGVycyh0ZW1wbGF0ZTogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nLCBwcm9qZWN0OiBQcm9qZWN0SW5mbywgcGFja2FnZU1hbmFnZXI/OiBKc1BhY2thZ2VNYW5hZ2VyKSB7XG4gIGNvbnN0IGNka0NsaVZlcnNpb24gPSBwcm9qZWN0LnZlcnNpb25zWydhd3MtY2RrJ107XG4gIGxldCBjZGtWZXJzaW9uID0gcHJvamVjdC52ZXJzaW9uc1snYXdzLWNkay1saWInXTtcbiAgbGV0IGNvbnN0cnVjdHNWZXJzaW9uID0gcHJvamVjdC52ZXJzaW9ucy5jb25zdHJ1Y3RzO1xuXG4gIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICBjYXNlICdqYXZhJzpcbiAgICAgIGNka1ZlcnNpb24gPSByYW5nZUZyb21TZW12ZXIoY2RrVmVyc2lvbiwgJ2JyYWNrZXQnKTtcbiAgICAgIGNvbnN0cnVjdHNWZXJzaW9uID0gcmFuZ2VGcm9tU2VtdmVyKGNvbnN0cnVjdHNWZXJzaW9uLCAnYnJhY2tldCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY3NoYXJwJzpcbiAgICBjYXNlICdmc2hhcnAnOlxuICAgICAgY2RrVmVyc2lvbiA9IHJhbmdlRnJvbVNlbXZlcihjZGtWZXJzaW9uLCAnYnJhY2tldCcpOyAvLyBeMi4xMjMuMCA9PiBbMi4xMjMuMCwzLjAuMClcbiAgICAgIGNvbnN0cnVjdHNWZXJzaW9uID0gcmFuZ2VGcm9tU2VtdmVyKGNvbnN0cnVjdHNWZXJzaW9uLCAnbWFqb3IuKicpOyAvLyBeMTAuMC4wID0+IDEwLiovXG4gICAgICBicmVhaztcbiAgICBjYXNlICdweXRob24nOlxuICAgICAgY2RrVmVyc2lvbiA9IHJhbmdlRnJvbVNlbXZlcihjZGtWZXJzaW9uLCAncGVwJyk7XG4gICAgICBjb25zdHJ1Y3RzVmVyc2lvbiA9IHJhbmdlRnJvbVNlbXZlcihjb25zdHJ1Y3RzVmVyc2lvbiwgJ3BlcCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZ28nOlxuICAgICAgY2RrVmVyc2lvbiA9IHN0cmlwQ2FyZXQoY2RrVmVyc2lvbik7XG4gICAgICBjb25zdHJ1Y3RzVmVyc2lvbiA9IHN0cmlwQ2FyZXQoY29uc3RydWN0c1ZlcnNpb24pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlXG4gICAgLnJlcGxhY2UoLyVuYW1lJS9nLCBwcm9qZWN0Lm5hbWUpXG4gICAgLnJlcGxhY2UoLyVzdGFja25hbWUlLywgcHJvamVjdC5zdGFja05hbWUgPz8gJyVuYW1lLlBhc2NhbENhc2VkJVN0YWNrJylcbiAgICAucmVwbGFjZShcbiAgICAgIC8lUGFzY2FsTmFtZVNwYWNlJS8sXG4gICAgICBwcm9qZWN0LnN0YWNrTmFtZSA/IGNhbWVsQ2FzZShwcm9qZWN0LnN0YWNrTmFtZSArICdTdGFjaycsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KSA6ICclbmFtZS5QYXNjYWxDYXNlZCUnLFxuICAgIClcbiAgICAucmVwbGFjZShcbiAgICAgIC8lUGFzY2FsU3RhY2tQcm9wcyUvLFxuICAgICAgcHJvamVjdC5zdGFja05hbWUgPyBjYW1lbENhc2UocHJvamVjdC5zdGFja05hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KSArICdTdGFja1Byb3BzJyA6ICdTdGFja1Byb3BzJyxcbiAgICApXG4gICAgLnJlcGxhY2UoLyVuYW1lXFwuY2FtZWxDYXNlZCUvZywgY2FtZWxDYXNlKHByb2plY3QubmFtZSkpXG4gICAgLnJlcGxhY2UoLyVuYW1lXFwuUGFzY2FsQ2FzZWQlL2csIGNhbWVsQ2FzZShwcm9qZWN0Lm5hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KSlcbiAgICAucmVwbGFjZSgvJWNkay12ZXJzaW9uJS9nLCBjZGtWZXJzaW9uKVxuICAgIC5yZXBsYWNlKC8lY2RrLWNsaS12ZXJzaW9uJS9nLCBjZGtDbGlWZXJzaW9uKVxuICAgIC5yZXBsYWNlKC8lY29uc3RydWN0cy12ZXJzaW9uJS9nLCBjb25zdHJ1Y3RzVmVyc2lvbilcbiAgICAucmVwbGFjZSgvJWNkay1ob21lJS9nLCBjZGtIb21lRGlyKCkpXG4gICAgLnJlcGxhY2UoLyVuYW1lXFwuUHl0aG9uTW9kdWxlJS9nLCBwcm9qZWN0Lm5hbWUucmVwbGFjZSgvLS9nLCAnXycpKVxuICAgIC5yZXBsYWNlKC8lcHl0aG9uLWV4ZWN1dGFibGUlL2csIHB5dGhvbkV4ZWN1dGFibGUoKSlcbiAgICAucmVwbGFjZSgvJW5hbWVcXC5TdGFja05hbWUlL2csIHByb2plY3QubmFtZS5yZXBsYWNlKC9bXkEtWmEtejAtOS1dL2csICctJykpXG4gICAgLnJlcGxhY2UoLyVwbS1jbWQlL2csIGdldFBtQ21kUHJlZml4KHBhY2thZ2VNYW5hZ2VyID8/ICducG0nKSk7XG59XG5cbmludGVyZmFjZSBQcm9qZWN0SW5mbyB7XG4gIC8qKiBUaGUgdmFsdWUgdXNlZCBmb3IgJW5hbWUlICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgc3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIHJlYWRvbmx5IHZlcnNpb25zOiBWZXJzaW9ucztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF2YWlsYWJsZUluaXRUZW1wbGF0ZXMoKTogUHJvbWlzZTxJbml0VGVtcGxhdGVbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRlbXBsYXRlc0RpciA9IHBhdGguam9pbihjbGlSb290RGlyKCksICdsaWInLCAnaW5pdC10ZW1wbGF0ZXMnKTtcbiAgICBjb25zdCB0ZW1wbGF0ZU5hbWVzID0gYXdhaXQgbGlzdERpcmVjdG9yeSh0ZW1wbGF0ZXNEaXIpO1xuICAgIGNvbnN0IHRlbXBsYXRlUHJvbWlzZXMgPSB0ZW1wbGF0ZU5hbWVzLm1hcCh0ZW1wbGF0ZU5hbWUgPT5cbiAgICAgIEluaXRUZW1wbGF0ZS5mcm9tTmFtZSh0ZW1wbGF0ZXNEaXIsIHRlbXBsYXRlTmFtZSksXG4gICAgKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc20gKi8gLy8gQnVpbHQtaW4gdGVtcGxhdGVzIGFyZSBsaW1pdGVkIGluIG51bWJlclxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh0ZW1wbGF0ZVByb21pc2VzKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIFJldHVybiBlbXB0eSBhcnJheSBpZiB0ZW1wbGF0ZXMgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3Qgb3IgY2FuJ3QgYmUgcmVhZFxuICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBDTEkgdG8gZ3JhY2VmdWxseSBoYW5kbGUgbWlzc2luZyBidWlsdC1pbiB0ZW1wbGF0ZXNcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZXJyb3IuY29kZSA9PT0gJ0VBQ0NFUycpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF2YWlsYWJsZUluaXRMYW5ndWFnZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCB0ZW1wbGF0ZXMgPSBhd2FpdCBhdmFpbGFibGVJbml0VGVtcGxhdGVzKCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIHRlbXBsYXRlcykge1xuICAgIGZvciAoY29uc3QgbGFuZ3VhZ2Ugb2YgdGVtcGxhdGUubGFuZ3VhZ2VzKSB7XG4gICAgICBjb25zdCBhbGlhcyA9IGdldExhbmd1YWdlQWxpYXMobGFuZ3VhZ2UpO1xuICAgICAgcmVzdWx0LmFkZChsYW5ndWFnZSk7XG4gICAgICBhbGlhcyAmJiByZXN1bHQuYWRkKGFsaWFzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5yZXN1bHRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSBkaXJQYXRoIC0gaXMgdGhlIGRpcmVjdG9yeSB0byBiZSBsaXN0ZWQuXG4gKiBAcmV0dXJucyB0aGUgbGlzdCBvZiBmaWxlIG9yIGRpcmVjdG9yeSBuYW1lcyBjb250YWluZWQgaW4gYGBkaXJQYXRoYGAsIGV4Y2x1ZGluZyBhbnkgZG90LWZpbGUsIGFuZCBzb3J0ZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxpc3REaXJlY3RvcnkoZGlyUGF0aDogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgKGF3YWl0IGZzLnJlYWRkaXIoZGlyUGF0aCkpXG4gICAgICAuZmlsdGVyKChwKSA9PiAhcC5zdGFydHNXaXRoKCcuJykpXG4gICAgICAuZmlsdGVyKChwKSA9PiAhKHAgPT09ICdMSUNFTlNFJykpXG4gICAgICAvLyBpZiwgZm9yIHNvbWUgcmVhc29uLCB0aGUgdGVtcCBmb2xkZXIgZm9yIHRoZSBob29rIGRvZXNuJ3QgZ2V0IGRlbGV0ZWQgd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IGl0IGluIHRoaXMgbGlzdFxuICAgICAgLmZpbHRlcigocCkgPT4gIShwID09PSBJTkZPX0RPVF9KU09OKSlcbiAgICAgIC5zb3J0KClcbiAgKTtcbn1cblxuLyoqXG4gKiBQcmludCBhdmFpbGFibGUgdGVtcGxhdGVzIHRvIHRoZSB1c2VyXG4gKiBAcGFyYW0gaW9IZWxwZXIgLSBJTyBoZWxwZXIgZm9yIHVzZXIgaW50ZXJhY3Rpb25cbiAqIEBwYXJhbSBsYW5ndWFnZSAtIFByb2dyYW1taW5nIGxhbmd1YWdlIGZpbHRlclxuICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmludEF2YWlsYWJsZVRlbXBsYXRlcyhpb0hlbHBlcjogSW9IZWxwZXIsIGxhbmd1YWdlPzogc3RyaW5nKSB7XG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oJ0F2YWlsYWJsZSB0ZW1wbGF0ZXM6Jyk7XG4gIGZvciAoY29uc3QgdGVtcGxhdGUgb2YgYXdhaXQgYXZhaWxhYmxlSW5pdFRlbXBsYXRlcygpKSB7XG4gICAgaWYgKGxhbmd1YWdlICYmIHRlbXBsYXRlLmxhbmd1YWdlcy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKGAqICR7Y2hhbGsuZ3JlZW4odGVtcGxhdGUubmFtZSl9OiAke3RlbXBsYXRlLmRlc2NyaXB0aW9uIX1gKTtcbiAgICBjb25zdCBsYW5ndWFnZUFyZyA9IGxhbmd1YWdlXG4gICAgICA/IGNoYWxrLmJvbGQobGFuZ3VhZ2UpXG4gICAgICA6IHRlbXBsYXRlLmxhbmd1YWdlcy5sZW5ndGggPiAxXG4gICAgICAgID8gYFske3RlbXBsYXRlLmxhbmd1YWdlcy5tYXAoKHQpID0+IGNoYWxrLmJvbGQodCkpLmpvaW4oJ3wnKX1dYFxuICAgICAgICA6IGNoYWxrLmJvbGQodGVtcGxhdGUubGFuZ3VhZ2VzWzBdKTtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKGAgICDilJTilIAgJHtjaGFsay5ibHVlKGBjZGsgaW5pdCAke2NoYWxrLmJvbGQodGVtcGxhdGUubmFtZSl9IC0tbGFuZ3VhZ2U9JHtsYW5ndWFnZUFyZ31gKX1gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplUHJvamVjdChcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICB0ZW1wbGF0ZTogSW5pdFRlbXBsYXRlLFxuICBsYW5ndWFnZTogc3RyaW5nLFxuICBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLFxuICBnZW5lcmF0ZU9ubHk6IGJvb2xlYW4sXG4gIHdvcmtEaXI6IHN0cmluZyxcbiAgcHJvamVjdE5hbWU/OiBzdHJpbmcsXG4gIHN0YWNrTmFtZT86IHN0cmluZyxcbiAgbWlncmF0ZT86IGJvb2xlYW4sXG4gIGNka1ZlcnNpb24/OiBzdHJpbmcsXG4gIHBhY2thZ2VNYW5hZ2VyPzogSnNQYWNrYWdlTWFuYWdlcixcbikge1xuICAvLyBTdGVwIDE6IEVuc3VyZSB0YXJnZXQgZGlyZWN0b3J5IGlzIGVtcHR5XG4gIGF3YWl0IGFzc2VydElzRW1wdHlEaXJlY3Rvcnkod29ya0Rpcik7XG5cbiAgLy8gU3RlcCAyOiBDb3B5IHRlbXBsYXRlIGZpbGVzXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEFwcGx5aW5nIHByb2plY3QgdGVtcGxhdGUgJHtjaGFsay5ncmVlbih0ZW1wbGF0ZS5uYW1lKX0gZm9yICR7Y2hhbGsuYmx1ZShsYW5ndWFnZSl9YCk7XG4gIGF3YWl0IHRlbXBsYXRlLmluc3RhbGwoaW9IZWxwZXIsIGxhbmd1YWdlLCB3b3JrRGlyLCBwcm9qZWN0TmFtZSwgc3RhY2tOYW1lLCBjZGtWZXJzaW9uLCBwYWNrYWdlTWFuYWdlcik7XG5cbiAgaWYgKG1pZ3JhdGUpIHtcbiAgICBhd2FpdCB0ZW1wbGF0ZS5hZGRNaWdyYXRlQ29udGV4dCh3b3JrRGlyKTtcbiAgfVxuXG4gIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGAke3dvcmtEaXJ9L1JFQURNRS5tZGApKSB7XG4gICAgY29uc3QgcmVhZG1lID0gYXdhaXQgZnMucmVhZEZpbGUoYCR7d29ya0Rpcn0vUkVBRE1FLm1kYCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKGNoYWxrLmdyZWVuKHJlYWRtZSkpO1xuICB9XG5cbiAgaWYgKCFnZW5lcmF0ZU9ubHkpIHtcbiAgICAvLyBTdGVwIDM6IEluaXRpYWxpemUgR2l0IHJlcG9zaXRvcnkgYW5kIGNyZWF0ZSBpbml0aWFsIGNvbW1pdFxuICAgIGF3YWl0IGluaXRpYWxpemVHaXRSZXBvc2l0b3J5KGlvSGVscGVyLCB3b3JrRGlyKTtcblxuICAgIC8vIFN0ZXAgNDogUG9zdC1pbnN0YWxsIHN0ZXBzXG4gICAgYXdhaXQgcG9zdEluc3RhbGwoaW9IZWxwZXIsIGxhbmd1YWdlLCBjYW5Vc2VOZXR3b3JrLCB3b3JrRGlyLCBwYWNrYWdlTWFuYWdlcik7XG4gIH1cblxuICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKCfinIUgQWxsIGRvbmUhJyk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhhdCBhIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGVtcHR5IChpZ25vcmluZyBoaWRkZW4gZmlsZXMpXG4gKiBAcGFyYW0gd29ya0RpciAtIERpcmVjdG9yeSBwYXRoIHRvIHZhbGlkYXRlXG4gKiBAdGhyb3dzIFRvb2xraXRFcnJvciBpZiBkaXJlY3RvcnkgZG9lc24ndCBleGlzdCBvciBpcyBub3QgZW1wdHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXNzZXJ0SXNFbXB0eURpcmVjdG9yeSh3b3JrRGlyOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnN0YXQod29ya0Rpcik7XG4gICAgaWYgKCFzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBQYXRoIGV4aXN0cyBidXQgaXMgbm90IGEgZGlyZWN0b3J5OiAke3dvcmtEaXJ9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHdvcmtEaXIpO1xuICAgIGNvbnN0IHZpc2libGVGaWxlcyA9IGZpbGVzLmZpbHRlcihmID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSk7XG5cbiAgICBpZiAodmlzaWJsZUZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgICdgY2RrIGluaXRgIGNhbm5vdCBiZSBydW4gaW4gYSBub24tZW1wdHkgZGlyZWN0b3J5IVxcbicgK1xuICAgICAgICBgRm91bmQgJHt2aXNpYmxlRmlsZXMubGVuZ3RofSB2aXNpYmxlIGZpbGVzIGluICR7d29ya0Rpcn06XFxuYCArXG4gICAgICAgIHZpc2libGVGaWxlcy5tYXAoZiA9PiBgICAtICR7Zn1gKS5qb2luKCdcXG4nKSxcbiAgICAgICk7XG4gICAgfVxuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgYERpcmVjdG9yeSBkb2VzIG5vdCBleGlzdDogJHt3b3JrRGlyfVxcbmAgK1xuICAgICAgICAnUGxlYXNlIGNyZWF0ZSB0aGUgZGlyZWN0b3J5IGZpcnN0IHVzaW5nOiBta2RpciAtcCAnICsgd29ya0RpcixcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYEZhaWxlZCB0byB2YWxpZGF0ZSBkaXJlY3RvcnkgJHt3b3JrRGlyfTogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUdpdFJlcG9zaXRvcnkoaW9IZWxwZXI6IElvSGVscGVyLCB3b3JrRGlyOiBzdHJpbmcpIHtcbiAgaWYgKGF3YWl0IGlzSW5HaXRSZXBvc2l0b3J5KHdvcmtEaXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oJ0luaXRpYWxpemluZyBhIG5ldyBnaXQgcmVwb3NpdG9yeS4uLicpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdnaXQnLCBbJ2luaXQnXSwgeyBjd2Q6IHdvcmtEaXIgfSk7XG4gICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJ2dpdCcsIFsnYWRkJywgJy4nXSwgeyBjd2Q6IHdvcmtEaXIgfSk7XG4gICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJ2dpdCcsIFsnY29tbWl0JywgJy0tbWVzc2FnZT1cIkluaXRpYWwgY29tbWl0XCInLCAnLS1uby1ncGctc2lnbiddLCB7IGN3ZDogd29ya0RpciB9KTtcbiAgfSBjYXRjaCB7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybignVW5hYmxlIHRvIGluaXRpYWxpemUgZ2l0IHJlcG9zaXRvcnkgZm9yIHlvdXIgcHJvamVjdC4nKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwb3N0SW5zdGFsbChpb0hlbHBlcjogSW9IZWxwZXIsIGxhbmd1YWdlOiBzdHJpbmcsIGNhblVzZU5ldHdvcms6IGJvb2xlYW4sIHdvcmtEaXI6IHN0cmluZywgcGFja2FnZU1hbmFnZXI/OiBKc1BhY2thZ2VNYW5hZ2VyKSB7XG4gIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICBjYXNlICdqYXZhc2NyaXB0JzpcbiAgICAgIHJldHVybiBwb3N0SW5zdGFsbEphdmFzY3JpcHQoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIsIHBhY2thZ2VNYW5hZ2VyKTtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiBwb3N0SW5zdGFsbFR5cGVzY3JpcHQoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIsIHBhY2thZ2VNYW5hZ2VyKTtcbiAgICBjYXNlICdqYXZhJzpcbiAgICAgIHJldHVybiBwb3N0SW5zdGFsbEphdmEoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIpO1xuICAgIGNhc2UgJ3B5dGhvbic6XG4gICAgICByZXR1cm4gcG9zdEluc3RhbGxQeXRob24oaW9IZWxwZXIsIHdvcmtEaXIpO1xuICAgIGNhc2UgJ2dvJzpcbiAgICAgIHJldHVybiBwb3N0SW5zdGFsbEdvKGlvSGVscGVyLCBjYW5Vc2VOZXR3b3JrLCB3b3JrRGlyKTtcbiAgICBjYXNlICdjc2hhcnAnOlxuICAgICAgcmV0dXJuIHBvc3RJbnN0YWxsQ1NoYXJwKGlvSGVscGVyLCBjYW5Vc2VOZXR3b3JrLCB3b3JrRGlyKTtcbiAgICBjYXNlICdmc2hhcnAnOlxuICAgICAgcmV0dXJuIHBvc3RJbnN0YWxsRlNoYXJwKGlvSGVscGVyLCBjYW5Vc2VOZXR3b3JrLCB3b3JrRGlyKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwb3N0SW5zdGFsbEphdmFzY3JpcHQoaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZywgcGFja2FnZU1hbmFnZXI/OiBKc1BhY2thZ2VNYW5hZ2VyKSB7XG4gIHJldHVybiBwb3N0SW5zdGFsbFR5cGVzY3JpcHQoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIGN3ZCwgcGFja2FnZU1hbmFnZXIpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwb3N0SW5zdGFsbFR5cGVzY3JpcHQoaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZywgcGFja2FnZU1hbmFnZXI/OiBKc1BhY2thZ2VNYW5hZ2VyKSB7XG4gIGNvbnN0IGNvbW1hbmQgPSBwYWNrYWdlTWFuYWdlciA/PyAnbnBtJztcblxuICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKGBQbGVhc2UgcnVuICcke2NvbW1hbmR9IGluc3RhbGwnIWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKGAke2NvbW1hbmR9IGluc3RhbGxgKX0uLi5gKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjdXRlKGlvSGVscGVyLCBjb21tYW5kLCBbJ2luc3RhbGwnXSwgeyBjd2QgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oYCR7Y29tbWFuZH0gaW5zdGFsbCBmYWlsZWQ6IGAgKyBmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsSmF2YShpb0hlbHBlcjogSW9IZWxwZXIsIGNhblVzZU5ldHdvcms6IGJvb2xlYW4sIGN3ZDogc3RyaW5nKSB7XG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBHcmFkbGUgb3IgTWF2ZW4gcHJvamVjdFxuICBjb25zdCBoYXNHcmFkbGVCdWlsZCA9IGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKGN3ZCwgJ2J1aWxkLmdyYWRsZScpKTtcbiAgY29uc3QgaGFzTWF2ZW5Qb20gPSBhd2FpdCBmcy5wYXRoRXhpc3RzKHBhdGguam9pbihjd2QsICdwb20ueG1sJykpO1xuXG4gIGlmIChoYXNHcmFkbGVCdWlsZCkge1xuICAgIC8vIEdyYWRsZSBwcm9qZWN0XG4gICAgY29uc3QgZ3JhZGxlV2FybmluZyA9IFwiUGxlYXNlIHJ1biAnLi9ncmFkbGV3IGJ1aWxkJyFcIjtcbiAgICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oZ3JhZGxlV2FybmluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhcIkV4ZWN1dGluZyAnLi9ncmFkbGV3IGJ1aWxkJ1wiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJy4vZ3JhZGxldycsIFsnYnVpbGQnXSwgeyBjd2QgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gYnVpbGQgR3JhZGxlIHByb2plY3QnKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oZ3JhZGxlV2FybmluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc01hdmVuUG9tKSB7XG4gICAgLy8gTWF2ZW4gcHJvamVjdFxuICAgIGNvbnN0IG12blBhY2thZ2VXYXJuaW5nID0gXCJQbGVhc2UgcnVuICdtdm4gcGFja2FnZSchXCI7XG4gICAgaWYgKCFjYW5Vc2VOZXR3b3JrKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKG12blBhY2thZ2VXYXJuaW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKFwiRXhlY3V0aW5nICdtdm4gcGFja2FnZSdcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdtdm4nLCBbJ3BhY2thZ2UnXSwgeyBjd2QgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gcGFja2FnZSBjb21waWxlZCBjb2RlIGFzIEpBUicpO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2Fybihtdm5QYWNrYWdlV2FybmluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5vIHJlY29nbml6ZWQgYnVpbGQgZmlsZVxuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oJ05vIGJ1aWxkLmdyYWRsZSBvciBwb20ueG1sIGZvdW5kLiBQbGVhc2Ugc2V0IHVwIHlvdXIgYnVpbGQgc3lzdGVtIG1hbnVhbGx5LicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsUHl0aG9uKGlvSGVscGVyOiBJb0hlbHBlciwgY3dkOiBzdHJpbmcpIHtcbiAgY29uc3QgcHl0aG9uID0gcHl0aG9uRXhlY3V0YWJsZSgpO1xuXG4gIC8vIENoZWNrIGlmIHJlcXVpcmVtZW50cy50eHQgZXhpc3RzXG4gIGNvbnN0IGhhc1JlcXVpcmVtZW50cyA9IGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKGN3ZCwgJ3JlcXVpcmVtZW50cy50eHQnKSk7XG5cbiAgaWYgKGhhc1JlcXVpcmVtZW50cykge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKCdDcmVhdGluZyB2aXJ0dWFsZW52Li4uJyl9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsIHB5dGhvbiwgWyctbScsICd2ZW52JywgJy52ZW52J10sIHsgY3dkIH0pO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgRXhlY3V0aW5nICR7Y2hhbGsuZ3JlZW4oJ0luc3RhbGxpbmcgZGVwZW5kZW5jaWVzLi4uJyl9YCk7XG4gICAgICAvLyBJbnN0YWxsIGRlcGVuZGVuY2llcyBpbiB0aGUgdmlydHVhbCBlbnZpcm9ubWVudFxuICAgICAgY29uc3QgcGlwUGF0aCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnLnZlbnZcXFxcU2NyaXB0c1xcXFxwaXAnIDogJy52ZW52L2Jpbi9waXAnO1xuICAgICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgcGlwUGF0aCwgWydpbnN0YWxsJywgJy1yJywgJ3JlcXVpcmVtZW50cy50eHQnXSwgeyBjd2QgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gY3JlYXRlIHZpcnR1YWxlbnYgb3IgaW5zdGFsbCBkZXBlbmRlbmNpZXMgYXV0b21hdGljYWxseScpO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybihgUGxlYXNlIHJ1biAnJHtweXRob259IC1tIHZlbnYgLnZlbnYgJiYgLnZlbnYvYmluL3BpcCBpbnN0YWxsIC1yIHJlcXVpcmVtZW50cy50eHQnIWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdObyByZXF1aXJlbWVudHMudHh0IGZvdW5kLiBQbGVhc2Ugc2V0IHVwIHlvdXIgUHl0aG9uIGVudmlyb25tZW50IG1hbnVhbGx5LicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsR28oaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZykge1xuICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdQbGVhc2UgcnVuIFxcJ2dvIG1vZCB0aWR5XFwnIScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKCdnbyBtb2QgdGlkeScpfS4uLmApO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdnbycsIFsnbW9kJywgJ3RpZHknXSwgeyBjd2QgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oJ1xcJ2dvIG1vZCB0aWR5XFwnIGZhaWxlZDogJyArIGZvcm1hdEVycm9yTWVzc2FnZShlKSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcG9zdEluc3RhbGxDU2hhcnAoaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZykge1xuICBjb25zdCBzb2x1dGlvbkRpciA9IHBhdGguam9pbihjd2QsICdzcmMnKTsgLy8gdGhlIGRvdG5ldCBzb2x1dGlvbiBpcyBpbnNpZGUgdGhlIHNyYyBkaXJcbiAgY29uc3QgZG90bmV0V2FybmluZyA9IFwiUGxlYXNlIHJ1biAnY2Qgc3JjICYmIGRvdG5ldCByZXN0b3JlICYmIGRvdG5ldCBidWlsZCchXCI7XG4gIGlmICghY2FuVXNlTmV0d29yaykge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oZG90bmV0V2FybmluZyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgRXhlY3V0aW5nICR7Y2hhbGsuZ3JlZW4oJ2RvdG5ldCByZXN0b3JlJyl9Li4uYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJ2RvdG5ldCcsIFsncmVzdG9yZSddLCB7IGN3ZDogc29sdXRpb25EaXIgfSk7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgRXhlY3V0aW5nICR7Y2hhbGsuZ3JlZW4oJ2RvdG5ldCBidWlsZCcpfS4uLmApO1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdkb3RuZXQnLCBbJ2J1aWxkJ10sIHsgY3dkOiBzb2x1dGlvbkRpciB9KTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybignVW5hYmxlIHRvIHJlc3RvcmUvYnVpbGQgLk5FVCBwcm9qZWN0OiAnICsgZm9ybWF0RXJyb3JNZXNzYWdlKGUpKTtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKGRvdG5ldFdhcm5pbmcpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsRlNoYXJwKGlvSGVscGVyOiBJb0hlbHBlciwgY2FuVXNlTmV0d29yazogYm9vbGVhbiwgY3dkOiBzdHJpbmcpIHtcbiAgLy8gRiMgdXNlcyB0aGUgc2FtZSBidWlsZCBzeXN0ZW0gYXMgQyNcbiAgcmV0dXJuIHBvc3RJbnN0YWxsQ1NoYXJwKGlvSGVscGVyLCBjYW5Vc2VOZXR3b3JrLCBjd2QpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBkaXIgLSBhIGRpcmVjdG9yeSB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB0cnVlIGlmIGBgZGlyYGAgaXMgd2l0aGluIGEgZ2l0IHJlcG9zaXRvcnkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzSW5HaXRSZXBvc2l0b3J5KGRpcjogc3RyaW5nKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKGRpciwgJy5naXQnKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNSb290KGRpcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlyID0gcGF0aC5kaXJuYW1lKGRpcik7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gZGlyIC0gYSBkaXJlY3RvcnkgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgYGBkaXJgYCBpcyB0aGUgcm9vdCBvZiBhIGZpbGVzeXN0ZW0uXG4gKi9cbmZ1bmN0aW9uIGlzUm9vdChkaXI6IHN0cmluZykge1xuICByZXR1cm4gcGF0aC5kaXJuYW1lKGRpcikgPT09IGRpcjtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBgY29tbWFuZGAuIFNUREVSUiBpcyBlbWl0dGVkIGluIHJlYWwtdGltZS5cbiAqXG4gKiBJZiBjb21tYW5kIGV4aXRzIHdpdGggbm9uLXplcm8gZXhpdCBjb2RlLCBhbiBleGNlcHRpb24gaXMgdGhyb3duIGFuZCBpbmNsdWRlc1xuICogdGhlIGNvbnRlbnRzIG9mIFNURE9VVC5cbiAqXG4gKiBAcmV0dXJucyBTVERPVVQgKGlmIHN1Y2Nlc3NmdWwpLlxuICovXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlKGlvSGVscGVyOiBJb0hlbHBlciwgY21kOiBzdHJpbmcsIGFyZ3M6IHN0cmluZ1tdLCB7IGN3ZCB9OiB7IGN3ZDogc3RyaW5nIH0pIHtcbiAgY29uc3QgY2hpbGQgPSBjaGlsZFByb2Nlc3Muc3Bhd24oY21kLCBhcmdzLCB7XG4gICAgY3dkLFxuICAgIHNoZWxsOiB0cnVlLFxuICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ2luaGVyaXQnXSxcbiAgfSk7XG4gIGxldCBzdGRvdXQgPSAnJztcbiAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgKGNodW5rKSA9PiAoc3Rkb3V0ICs9IGNodW5rLnRvU3RyaW5nKCkpKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKG9rLCBmYWlsKSA9PiB7XG4gICAgY2hpbGQub25jZSgnZXJyb3InLCAoZXJyKSA9PiBmYWlsKGVycikpO1xuICAgIGNoaWxkLm9uY2UoJ2V4aXQnLCAoc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvayhzdGRvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhaWwobmV3IFRvb2xraXRFcnJvcihgJHtjbWR9IGV4aXRlZCB3aXRoIHN0YXR1cyAke3N0YXR1c31gKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLmNhdGNoKGFzeW5jIChlcnIpID0+IHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5lcnJvcihzdGRvdXQpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbmludGVyZmFjZSBWZXJzaW9ucyB7XG4gIFsnYXdzLWNkayddOiBzdHJpbmc7XG4gIFsnYXdzLWNkay1saWInXTogc3RyaW5nO1xuICBjb25zdHJ1Y3RzOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSAnYXdzLWNkay1saWInIHZlcnNpb24gd2Ugd2lsbCBpbml0XG4gKlxuICogVGhpcyBoYXMgYmVlbiBidWlsdCBpbnRvIHRoZSBDTEkgYXQgYnVpbGQgdGltZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZEluaXRWZXJzaW9ucygpOiBQcm9taXNlPFZlcnNpb25zPiB7XG4gIGNvbnN0IGluaXRWZXJzaW9uRmlsZSA9IHBhdGguam9pbihjbGlSb290RGlyKCksICdsaWInLCAnaW5pdC10ZW1wbGF0ZXMnLCAnLmluaXQtdmVyc2lvbi5qc29uJyk7XG4gIGNvbnN0IGNvbnRlbnRzID0gSlNPTi5wYXJzZShhd2FpdCBmcy5yZWFkRmlsZShpbml0VmVyc2lvbkZpbGUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSkpO1xuXG4gIGNvbnN0IHJldCA9IHtcbiAgICAnYXdzLWNkay1saWInOiBjb250ZW50c1snYXdzLWNkay1saWInXSxcbiAgICAnY29uc3RydWN0cyc6IGNvbnRlbnRzLmNvbnN0cnVjdHMsXG4gICAgJ2F3cy1jZGsnOiB2ZXJzaW9uTnVtYmVyKCksXG4gIH07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJldCkpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBNaXNzaW5nIGluaXQgdmVyc2lvbiBmcm9tICR7aW5pdFZlcnNpb25GaWxlfTogJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGN1cnJlbnRseSByZWNvbW1lbmRlZCBmbGFncyBmb3IgYGF3cy1jZGstbGliYC5cbiAqXG4gKiBUaGVzZSBoYXZlIGJlZW4gYnVpbHQgaW50byB0aGUgQ0xJIGF0IGJ1aWxkIHRpbWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjdXJyZW50bHlSZWNvbW1lbmRlZEF3c0Nka0xpYkZsYWdzKCkge1xuICBjb25zdCByZWNvbW1lbmRlZEZsYWdzRmlsZSA9IHBhdGguam9pbihjbGlSb290RGlyKCksICdsaWInLCAnaW5pdC10ZW1wbGF0ZXMnLCAnLnJlY29tbWVuZGVkLWZlYXR1cmUtZmxhZ3MuanNvbicpO1xuICByZXR1cm4gSlNPTi5wYXJzZShhd2FpdCBmcy5yZWFkRmlsZShyZWNvbW1lbmRlZEZsYWdzRmlsZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSk7XG59XG4iXX0=